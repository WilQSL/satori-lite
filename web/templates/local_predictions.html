{% extends "base.html" %}

{% block title %}Satori - Local Predictions{% endblock %}

{% block extra_css %}
<style>
    .metric-value {
        font-size: 1.5rem;
        font-weight: 700;
    }
    .metric-label {
        color: var(--text-secondary);
        font-size: 0.85rem;
    }
    .chart-wrap {
        height: 320px;
    }
    .table-responsive {
        max-height: 460px;
        overflow-y: auto;
    }
    .table-responsive thead th {
        position: sticky;
        top: 0;
        background: var(--bg-card);
        color: var(--text-primary);
        z-index: 1;
    }
    .table {
        color: var(--text-primary);
    }
    .table tbody td {
        color: var(--text-primary) !important;
        background: var(--bg-card);
    }
    .table tbody tr:nth-child(even) td {
        background: var(--bg-input);
    }
    .table-sm td, .table-sm th {
        vertical-align: middle;
    }
    .mono {
        font-family: Consolas, "Courier New", monospace;
    }
    .loading-overlay {
        position: fixed;
        inset: 0;
        background: rgba(8, 8, 12, 0.78);
        backdrop-filter: blur(3px);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 2000;
    }
    .loading-card {
        width: min(92vw, 460px);
        background: linear-gradient(180deg, rgba(20, 20, 20, 0.96), rgba(12, 12, 14, 0.96));
        border: 1px solid var(--border-color);
        border-radius: 14px;
        padding: 1.2rem 1.3rem;
        box-shadow: var(--shadow);
    }
    .loading-title {
        font-size: 0.95rem;
        font-weight: 600;
        margin-bottom: 0.6rem;
        color: var(--text-primary);
    }
    .loading-progress {
        height: 8px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.08);
        overflow: hidden;
    }
    .loading-progress-bar {
        height: 100%;
        width: 0%;
        background: var(--accent-gradient);
        transition: width 0.25s ease;
    }
    .loading-meta {
        margin-top: 0.5rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: var(--text-secondary);
        font-size: 0.8rem;
    }
</style>
{% endblock %}

{% block content %}
{% include 'partials/navbar.html' %}

<div class="container-fluid py-4">
    <div class="row g-4">
        <div class="col-12">
            <div class="card">
                <div class="card-body">
                    <div class="row g-3 align-items-end">
                        <div class="col-12 col-lg-6">
                            <label for="streamSelect" class="form-label">Local stream</label>
                            <select id="streamSelect" class="form-select"></select>
                        </div>
                        <div class="col-12 col-lg-6 d-flex justify-content-lg-end">
                            <button class="btn btn-primary" id="refreshBtn">
                                <i class="material-icons align-middle me-1" style="font-size: 16px;">refresh</i>
                                Refresh
                            </button>
                        </div>
                    </div>
                    <div class="mt-3 small text-muted" id="streamMeta">-</div>
                    <div class="mt-2 small text-muted">
                        Active streams: <strong id="activeStreamsCount">0</strong>
                        <span class="mx-2">|</span>
                        Predictions last 24h: <strong id="predictions24hTotal">0</strong>
                    </div>
                    <div class="mt-3 alert alert-secondary mb-0" id="statusBox">Loading local predictions...</div>
                </div>
            </div>
        </div>

        <div class="col-12 col-md-6 col-xl-3">
            <div class="card h-100"><div class="card-body">
                <div class="metric-value" id="obsCount">0</div>
                <div class="metric-label">Observations</div>
            </div></div>
        </div>
        <div class="col-12 col-md-6 col-xl-3">
            <div class="card h-100"><div class="card-body">
                <div class="metric-value" id="predCount">0</div>
                <div class="metric-label">Predictions</div>
            </div></div>
        </div>
        <div class="col-12 col-md-6 col-xl-3">
            <div class="card h-100"><div class="card-body">
                <div class="metric-value" id="avgAbsError">-</div>
                <div class="metric-label">Avg absolute error</div>
            </div></div>
        </div>
        <div class="col-12 col-md-6 col-xl-3">
            <div class="card h-100"><div class="card-body">
                <div class="metric-value" id="accuracyPct">-</div>
                <div class="metric-label">Accuracy</div>
            </div></div>
        </div>

        <div class="col-12 col-xl-6">
            <div class="card">
                <div class="card-header">
                    <h6 class="mb-0">Observations vs predictions</h6>
                </div>
                <div class="card-body">
                    <div class="chart-wrap">
                        <canvas id="predictionsChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-12 col-xl-6">
            <div class="card">
                <div class="card-header">
                    <h6 class="mb-0">Prediction error (absolute)</h6>
                </div>
                <div class="card-body">
                    <div class="chart-wrap">
                        <canvas id="errorChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h6 class="mb-0">Recent local predictions</h6>
                </div>
                <div class="card-body table-responsive" style="max-height: 360px;">
                    <table class="table table-sm table-hover mb-0">
                        <thead>
                            <tr>
                                <th>Prediction time</th>
                                <th>Predicted</th>
                                <th>Matched observation</th>
                                <th>Abs error</th>
                            </tr>
                        </thead>
                        <tbody id="predictionRows">
                            <tr><td colspan="4" class="text-muted">Loading...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="loadingOverlay" class="loading-overlay" aria-hidden="true">
    <div class="loading-card">
        <div class="loading-title" id="loadingTitle">Loading local predictions...</div>
        <div class="loading-progress">
            <div id="loadingProgressBar" class="loading-progress-bar"></div>
        </div>
        <div class="loading-meta">
            <span id="loadingStep">Preparing data...</span>
            <strong id="loadingPercent">0%</strong>
        </div>
    </div>
</div>

<div class="toast-container position-fixed bottom-0 end-0 p-3">
    <div id="statusToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-header">
            <strong class="me-auto">Satori</strong>
            <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body" id="toastMessage"></div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
let predictionsChart = null;
let errorChart = null;
let currentStream = '';
let allStreams = [];
let loadingHideTimer = null;

function showToast(message, isError = false) {
    const toast = document.getElementById('statusToast');
    const toastBody = document.getElementById('toastMessage');
    toastBody.textContent = message;
    toastBody.className = 'toast-body ' + (isError ? 'text-danger' : 'text-success');
    const bsToast = new bootstrap.Toast(toast);
    bsToast.show();
}

function showLoading(message = 'Loading local predictions...', step = 'Preparing data...', percent = 0) {
    const overlay = document.getElementById('loadingOverlay');
    const title = document.getElementById('loadingTitle');
    const stepEl = document.getElementById('loadingStep');
    const percentEl = document.getElementById('loadingPercent');
    const bar = document.getElementById('loadingProgressBar');

    if (loadingHideTimer) {
        clearTimeout(loadingHideTimer);
        loadingHideTimer = null;
    }

    overlay.style.display = 'flex';
    overlay.setAttribute('aria-hidden', 'false');
    title.textContent = message;
    stepEl.textContent = step;
    percentEl.textContent = `${Math.max(0, Math.min(100, percent))}%`;
    bar.style.width = `${Math.max(0, Math.min(100, percent))}%`;
}

function updateLoading(step, percent) {
    const stepEl = document.getElementById('loadingStep');
    const percentEl = document.getElementById('loadingPercent');
    const bar = document.getElementById('loadingProgressBar');
    stepEl.textContent = step;
    percentEl.textContent = `${Math.max(0, Math.min(100, percent))}%`;
    bar.style.width = `${Math.max(0, Math.min(100, percent))}%`;
}

function hideLoading() {
    updateLoading('Done', 100);
    loadingHideTimer = setTimeout(() => {
        const overlay = document.getElementById('loadingOverlay');
        overlay.style.display = 'none';
        overlay.setAttribute('aria-hidden', 'true');
        loadingHideTimer = null;
    }, 220);
}

function sliderToSeconds(sliderValue) {
    const percentage = sliderValue / 100.0;
    if (percentage <= 0.0) return 86400;
    if (percentage >= 1.0) return 0;
    return Math.round(86400 * Math.pow(1 - percentage, 7));
}

function secondsToSlider(seconds) {
    if (seconds >= 86400) return 0;
    if (seconds <= 0) return 100;
    const percentage = 1 - Math.pow(seconds / 86400, 1 / 7);
    return Math.round(percentage * 100);
}

function formatDelay(seconds) {
    if (seconds === 0) return "Continuous";
    if (seconds < 60) return `${seconds} seconds`;
    if (seconds < 3600) return `${Math.round(seconds / 60)} minutes`;
    if (seconds < 86400) return `${Math.round(seconds / 3600)} hours`;
    return `${Math.round(seconds / 86400)} days`;
}

function updateTrainingDelayLabel(sliderValue) {
    const seconds = sliderToSeconds(sliderValue);
    document.getElementById('trainingDelayLabel').textContent = formatDelay(seconds);
}

async function setTrainingDelay(sliderValue) {
    const seconds = sliderToSeconds(sliderValue);
    try {
        const response = await fetch('/api/engine/training-delay', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ delay_seconds: seconds }),
        });
        if (response.ok) {
            showToast(`Training frequency updated: ${formatDelay(seconds)}`);
        } else {
            showToast('Failed to update training frequency', true);
        }
    } catch (error) {
        console.error('Error setting training delay:', error);
        showToast('Failed to update training frequency', true);
    }
}

async function loadTrainingDelay() {
    try {
        const response = await fetch('/api/engine/training-delay');
        const result = await response.json();
        if (response.ok && result.delay_seconds !== undefined) {
            const sliderValue = secondsToSlider(result.delay_seconds);
            document.getElementById('trainingDelaySlider').value = sliderValue;
            updateTrainingDelayLabel(sliderValue);
        }
    } catch (error) {
        console.error('Error loading training delay:', error);
    }
}

function shortUuid(uuid) {
    if (!uuid || uuid.length < 16) return uuid || '-';
    return `${uuid.slice(0, 8)}...${uuid.slice(-6)}`;
}

function isUuidLike(value) {
    if (!value || typeof value !== 'string') return false;
    return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value);
}

function parseTimestamp(ts) {
    if (typeof ts === 'number') {
        const value = ts > 1e12 ? ts : ts * 1000;
        return new Date(value);
    }
    if (typeof ts === 'string') {
        const numeric = Number(ts);
        if (!Number.isNaN(numeric)) {
            const value = numeric > 1e12 ? numeric : numeric * 1000;
            return new Date(value);
        }
    }
    return new Date(ts);
}

function formatDateTime(ts) {
    const date = parseTimestamp(ts);
    if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
        return String(ts);
    }
    return date.toLocaleString(undefined, {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false,
    });
}

function formatNumber(value, decimals = 4) {
    if (value === null || value === undefined || Number.isNaN(Number(value))) return '-';
    return Number(value).toFixed(decimals);
}

function setStatus(message, type = 'secondary') {
    const box = document.getElementById('statusBox');
    box.className = `mt-3 alert alert-${type} mb-0`;
    box.textContent = message;
}

async function fetchJson(url) {
    const response = await fetch(url);
    const payload = await response.json();
    if (!response.ok) {
        throw new Error(payload.error || `Request failed: ${response.status}`);
    }
    return payload;
}

function getStreamDisplayName(stream, index = 0) {
    if (!stream) return `Stream ${index + 1}`;
    if (stream.stream_display_name) return stream.stream_display_name;
    const name = (stream.stream_name || '').trim();
    if (name && !isUuidLike(name)) return name;
    return `Stream ${index + 1}`;
}

function updateStreamMeta(stream) {
    const meta = document.getElementById('streamMeta');
    if (!stream) {
        meta.textContent = '-';
        return;
    }
    const display = getStreamDisplayName(stream);
    meta.innerHTML = `
        <span class="me-3"><strong>${display}</strong></span>
        <span class="me-3">Stream UUID: <span class="mono">${shortUuid(stream.stream_uuid)}</span></span>
        <span>Prediction UUID: <span class="mono">${shortUuid(stream.prediction_stream_uuid)}</span></span>
    `;
}

async function loadStreams() {
    const select = document.getElementById('streamSelect');
    select.disabled = true;
    setStatus('Loading streams...', 'secondary');
    showLoading('Loading local predictions...', 'Fetching stream list...', 15);

    try {
        const data = await fetchJson('/api/engine/streams');
        updateLoading('Stream list ready', 45);
        const streams = data.streams || [];
        allStreams = streams;
        document.getElementById('activeStreamsCount').textContent = data.active_model_count || 0;
        document.getElementById('predictions24hTotal').textContent = data.predictions_24h_total || 0;

        select.innerHTML = '';
        if (streams.length === 0) {
            select.innerHTML = '<option value="">No local streams found</option>';
            updateMetrics({}, [], [], []);
            renderRows([], []);
            updateStreamMeta(null);
            setStatus('No local streams available yet.', 'warning');
            hideLoading();
            return;
        }

        streams.forEach((stream, index) => {
            const option = document.createElement('option');
            option.value = stream.stream_uuid;
            option.textContent = `${getStreamDisplayName(stream, index)} | ${shortUuid(stream.stream_uuid)}`;
            select.appendChild(option);
        });

        if (currentStream && streams.some((s) => s.stream_uuid === currentStream)) {
            select.value = currentStream;
        } else {
            currentStream = streams[0].stream_uuid;
            select.value = currentStream;
        }

        updateStreamMeta(streams.find((s) => s.stream_uuid === select.value));
        updateLoading('Loading selected stream performance...', 62);
        await loadPerformance();
    } catch (error) {
        setStatus(`Failed to load streams: ${error.message}`, 'danger');
        select.innerHTML = '<option value="">Stream load failed</option>';
        hideLoading();
    } finally {
        select.disabled = false;
    }
}

function updateMetrics(stats, observations, predictions, accuracy) {
    document.getElementById('obsCount').textContent = observations.length;
    document.getElementById('predCount').textContent = predictions.length;
    document.getElementById('avgAbsError').textContent = stats.avg_abs_error !== undefined
        ? formatNumber(stats.avg_abs_error, 4)
        : '-';
    document.getElementById('accuracyPct').textContent = stats.accuracy_pct !== undefined
        ? `${formatNumber(stats.accuracy_pct, 2)}%`
        : '-';
}

function renderPredictionsChart(observations, predictions) {
    const ctx = document.getElementById('predictionsChart');
    if (predictionsChart) {
        predictionsChart.destroy();
    }

    predictionsChart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [
                {
                    label: 'Observations',
                    data: observations.map((o) => ({ x: parseTimestamp(o.ts), y: Number(o.value) })),
                    borderColor: '#22c55e',
                    backgroundColor: 'rgba(34, 197, 94, 0.2)',
                    tension: 0.2,
                    pointRadius: 2,
                },
                {
                    label: 'Predictions',
                    data: predictions.map((p) => ({ x: parseTimestamp(p.ts), y: Number(p.value) })),
                    borderColor: '#3b82f6',
                    backgroundColor: 'rgba(59, 130, 246, 0.2)',
                    tension: 0.2,
                    pointRadius: 2,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: { type: 'time', time: { tooltipFormat: 'yyyy-MM-dd HH:mm' } },
                y: { ticks: { maxTicksLimit: 8 } }
            }
        }
    });
}

function renderErrorChart(accuracy) {
    const ctx = document.getElementById('errorChart');
    if (errorChart) {
        errorChart.destroy();
    }

    errorChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: accuracy.map((a) => parseTimestamp(a.ts)),
            datasets: [{
                label: 'Absolute error',
                data: accuracy.map((a) => Number(a.abs_error)),
                backgroundColor: 'rgba(244, 63, 94, 0.6)',
                borderColor: '#f43f5e',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: { type: 'time', time: { tooltipFormat: 'yyyy-MM-dd HH:mm' } },
                y: { beginAtZero: true }
            }
        }
    });
}

function renderRows(predictions, accuracy) {
    const tbody = document.getElementById('predictionRows');
    if (!predictions.length) {
        tbody.innerHTML = '<tr><td colspan="4" class="text-muted">No local predictions found.</td></tr>';
        return;
    }

    const accuracyByTs = new Map(accuracy.map((a) => [String(a.ts), a]));
    const rows = predictions
        .slice()
        .reverse()
        .slice(0, 80)
        .map((prediction) => {
            const item = accuracyByTs.get(String(prediction.ts));
            const matched = item ? formatNumber(item.actual, 4) : '-';
            const absError = item ? formatNumber(item.abs_error, 4) : '-';
            return `
                <tr>
                    <td title="${prediction.ts}">${formatDateTime(prediction.ts)}</td>
                    <td>${formatNumber(prediction.value, 4)}</td>
                    <td>${matched}</td>
                    <td>${absError}</td>
                </tr>
            `;
        });

    tbody.innerHTML = rows.join('');
}

async function loadPerformance() {
    const select = document.getElementById('streamSelect');
    const streamUuid = select.value;
    if (!streamUuid) {
        return;
    }

    currentStream = streamUuid;
    setStatus('Loading predictions for selected stream...', 'secondary');
    showLoading('Loading local predictions...', 'Fetching predictions and observations...', 70);

    try {
        const data = await fetchJson(`/api/engine/performance?stream_uuid=${encodeURIComponent(streamUuid)}&limit=500`);
        updateLoading('Processing and rendering charts...', 88);
        const observations = data.observations || [];
        const predictions = data.predictions || [];
        const accuracy = data.accuracy || [];
        const stats = data.stats || {};
        const stream = allStreams.find((s) => s.stream_uuid === streamUuid);

        updateMetrics(stats, observations, predictions, accuracy);
        updateStreamMeta(stream);
        renderPredictionsChart(observations, predictions);
        renderErrorChart(accuracy);
        renderRows(predictions, accuracy);

        setStatus(
            `Loaded ${predictions.length} predictions and ${observations.length} observations for ${getStreamDisplayName(stream)} (${shortUuid(streamUuid)}).`,
            'success'
        );
        hideLoading();
    } catch (error) {
        setStatus(`Failed to load performance data: ${error.message}`, 'danger');
        hideLoading();
    }
}

document.addEventListener('DOMContentLoaded', async () => {
    document.getElementById('refreshBtn').addEventListener('click', async () => {
        await loadPerformance();
    });
    document.getElementById('streamSelect').addEventListener('change', async () => {
        const stream = allStreams.find((s) => s.stream_uuid === document.getElementById('streamSelect').value);
        updateStreamMeta(stream);
        await loadPerformance();
    });

    await loadTrainingDelay();
    await loadStreams();
});
</script>
{% endblock %}
