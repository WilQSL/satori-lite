{% extends "base.html" %}

{% block title %}Satori - Local Predictions{% endblock %}

{% block extra_css %}
<style>
    .metric-value {
        font-size: 1.5rem;
        font-weight: 700;
    }
    .metric-label {
        color: var(--text-secondary);
        font-size: 0.85rem;
    }
    .chart-wrap {
        height: 320px;
    }
    .table-responsive {
        max-height: 460px;
        overflow-y: auto;
    }
    .table-responsive thead th {
        position: sticky;
        top: 0;
        background: var(--bg-card);
        color: var(--text-primary);
        z-index: 1;
    }
    .table {
        color: var(--text-primary);
    }
    .table tbody td {
        color: var(--text-primary) !important;
        background: var(--bg-card);
    }
    .table tbody tr:nth-child(even) td {
        background: var(--bg-input);
    }
    .table-sm td, .table-sm th {
        vertical-align: middle;
    }
    .analytics-table {
        border-collapse: separate;
        border-spacing: 0;
    }
    .analytics-table thead th {
        font-size: 0.72rem;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: var(--text-secondary);
        border-bottom: 1px solid var(--border-color);
        padding-top: 0.65rem;
        padding-bottom: 0.65rem;
        background: var(--bg-card);
    }
    .analytics-table tbody td {
        border-bottom: 1px solid rgba(255, 255, 255, 0.04);
        font-size: 0.86rem;
    }
    .analytics-table tbody tr:hover td {
        background: rgba(90, 90, 255, 0.06) !important;
    }
    .numeric-cell {
        text-align: right;
        font-variant-numeric: tabular-nums;
        font-family: Consolas, "Courier New", monospace;
    }
    .time-cell {
        min-width: 152px;
        font-variant-numeric: tabular-nums;
        font-family: Consolas, "Courier New", monospace;
        color: var(--text-secondary);
    }
    .delta-chip {
        display: inline-flex;
        align-items: center;
        gap: 0.2rem;
        border-radius: 999px;
        padding: 0.12rem 0.42rem;
        font-size: 0.75rem;
        font-weight: 600;
        font-variant-numeric: tabular-nums;
    }
    .delta-chip.low {
        color: #22c55e;
        background: rgba(34, 197, 94, 0.16);
    }
    .delta-chip.mid {
        color: #f59e0b;
        background: rgba(245, 158, 11, 0.16);
    }
    .delta-chip.high {
        color: #ef4444;
        background: rgba(239, 68, 68, 0.16);
    }
    .subtle-value {
        color: var(--text-secondary);
    }
    .analytic-pill {
        display: inline-flex;
        align-items: center;
        gap: 0.2rem;
        border-radius: 999px;
        padding: 0.12rem 0.45rem;
        font-size: 0.78rem;
        font-weight: 600;
    }
    .analytic-pill.up {
        color: #22c55e;
        background: rgba(34, 197, 94, 0.14);
    }
    .analytic-pill.down {
        color: #ef4444;
        background: rgba(239, 68, 68, 0.14);
    }
    .analytic-pill.flat {
        color: #9ca3af;
        background: rgba(156, 163, 175, 0.12);
    }
    .obs-change-up {
        color: #22c55e;
        font-weight: 600;
    }
    .obs-change-down {
        color: #ef4444;
        font-weight: 600;
    }
    .obs-change-flat {
        color: #9ca3af;
        font-weight: 600;
    }
    .mono {
        font-family: Consolas, "Courier New", monospace;
    }
    .loading-overlay {
        position: fixed;
        inset: 0;
        background: rgba(8, 8, 12, 0.78);
        backdrop-filter: blur(3px);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 2000;
    }
    .loading-card {
        width: min(92vw, 460px);
        background: linear-gradient(180deg, rgba(20, 20, 20, 0.96), rgba(12, 12, 14, 0.96));
        border: 1px solid var(--border-color);
        border-radius: 14px;
        padding: 1.2rem 1.3rem;
        box-shadow: var(--shadow);
    }
    .loading-title {
        font-size: 0.95rem;
        font-weight: 600;
        margin-bottom: 0.6rem;
        color: var(--text-primary);
    }
    .loading-progress {
        height: 8px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.08);
        overflow: hidden;
    }
    .loading-progress-bar {
        height: 100%;
        width: 0%;
        background: var(--accent-gradient);
        transition: width 0.25s ease;
    }
    .loading-meta {
        margin-top: 0.5rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: var(--text-secondary);
        font-size: 0.8rem;
    }
    .range-btn-group {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
    }
    .range-btn {
        min-width: 48px;
    }
    .stream-picker-btn {
        background: var(--bg-input);
        border: 1px solid var(--border-color);
        color: var(--text-primary);
        border-radius: 8px;
        padding: 0.6rem 0.75rem;
    }
    .stream-picker-btn:hover,
    .stream-picker-btn:focus {
        background: var(--bg-input-focus);
        border-color: var(--border-color-focus);
        color: var(--text-primary);
    }
    .stream-picker-label {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: calc(100% - 24px);
        font-weight: 600;
    }
    .stream-dropdown-menu {
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        min-width: 100%;
        max-height: 360px;
        overflow: hidden;
    }
    .stream-list {
        max-height: 260px;
        overflow-y: auto;
    }
    .stream-option {
        border-radius: 6px;
        margin-bottom: 0.2rem;
        color: var(--text-primary);
        background: transparent;
        border: 1px solid transparent;
    }
    .stream-option.active,
    .stream-option:hover {
        background: rgba(90, 90, 255, 0.14);
        border-color: rgba(90, 90, 255, 0.3);
        color: var(--text-primary);
    }
    .stream-option .title {
        font-weight: 600;
    }
    .stream-option .meta {
        color: var(--text-secondary);
        font-size: 0.78rem;
    }
</style>
{% endblock %}

{% block content %}
{% include 'partials/navbar.html' %}

<div class="container-fluid py-4">
    <div class="row g-4" id="localPredictionsLayoutRow">
        <div class="col-12 dashboard-widget-col" data-widget-id="lp_filters">
            <div class="card">
                <div class="card-body">
                    <div class="row g-3 align-items-end">
                        <div class="col-12 col-lg-5">
                            <label class="form-label">Data window</label>
                            <div class="range-btn-group" id="rangeButtons">
                                <button type="button" class="btn btn-outline-light btn-sm range-btn" data-days="1">1d</button>
                                <button type="button" class="btn btn-outline-light btn-sm range-btn" data-days="5">5d</button>
                                <button type="button" class="btn btn-primary btn-sm range-btn" data-days="10">10d</button>
                                <button type="button" class="btn btn-outline-light btn-sm range-btn" data-days="30">30d</button>
                                <button type="button" class="btn btn-outline-light btn-sm range-btn" data-days="all">All</button>
                            </div>
                        </div>
                        <div class="col-12 col-lg-5">
                            <label for="streamDropdownBtn" class="form-label">Local stream</label>
                            <div class="dropdown">
                                <button class="btn stream-picker-btn w-100 d-flex justify-content-between align-items-center"
                                        type="button"
                                        id="streamDropdownBtn"
                                        data-bs-toggle="dropdown"
                                        data-bs-auto-close="outside"
                                        aria-expanded="false">
                                    <span class="stream-picker-label" id="streamDropdownLabel">Select stream</span>
                                    <i class="material-icons align-middle" style="font-size: 18px;">expand_more</i>
                                </button>
                                <div class="dropdown-menu stream-dropdown-menu p-2" aria-labelledby="streamDropdownBtn">
                                    <div class="input-group input-group-sm mb-2">
                                        <span class="input-group-text"><i class="material-icons align-middle" style="font-size: 16px;">search</i></span>
                                        <input type="text" class="form-control" id="streamSearchInput" placeholder="Find stream...">
                                    </div>
                                    <div id="streamDropdownList" class="stream-list"></div>
                                </div>
                            </div>
                            <select id="streamSelect" class="d-none"></select>
                        </div>
                        <div class="col-12 col-lg-2 d-flex justify-content-lg-end">
                            <button class="btn btn-primary" id="refreshBtn">
                                <i class="material-icons align-middle me-1" style="font-size: 16px;">refresh</i>
                                Refresh
                            </button>
                        </div>
                    </div>
                    <div class="mt-3 small text-muted" id="streamMeta">-</div>
                    <div class="mt-2 small text-muted">
                        Active streams: <strong id="activeStreamsCount">0</strong>
                        <span class="mx-2">|</span>
                        Predictions last 24h: <strong id="predictions24hTotal">0</strong>
                    </div>
                    <div class="mt-3 alert alert-secondary mb-0" id="statusBox">Loading local predictions...</div>
                </div>
            </div>
        </div>

        <div class="col-12 col-md-6 col-xl-3 dashboard-widget-col" data-widget-id="lp_obs">
            <div class="card h-100"><div class="card-body">
                <div class="metric-value" id="obsCount">0</div>
                <div class="metric-label">Observations</div>
            </div></div>
        </div>
        <div class="col-12 col-md-6 col-xl-3 dashboard-widget-col" data-widget-id="lp_pred">
            <div class="card h-100"><div class="card-body">
                <div class="metric-value" id="predCount">0</div>
                <div class="metric-label">Predictions</div>
            </div></div>
        </div>
        <div class="col-12 col-md-6 col-xl-3 dashboard-widget-col" data-widget-id="lp_avgerr">
            <div class="card h-100"><div class="card-body">
                <div class="metric-value" id="avgAbsError">-</div>
                <div class="metric-label">Avg absolute error</div>
            </div></div>
        </div>
        <div class="col-12 col-md-6 col-xl-3 dashboard-widget-col" data-widget-id="lp_acc">
            <div class="card h-100"><div class="card-body">
                <div class="metric-value" id="accuracyPct">-</div>
                <div class="metric-label">Accuracy</div>
            </div></div>
        </div>

        <div class="col-12 col-xl-6 dashboard-widget-col" data-widget-id="lp_chart_pred">
            <div class="card">
                <div class="card-header">
                    <h6 class="mb-0">Observations vs predictions</h6>
                </div>
                <div class="card-body">
                    <div class="chart-wrap">
                        <canvas id="predictionsChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-12 col-xl-6 dashboard-widget-col" data-widget-id="lp_chart_err">
            <div class="card">
                <div class="card-header">
                    <h6 class="mb-0">Prediction error (absolute)</h6>
                </div>
                <div class="card-body">
                    <div class="chart-wrap">
                        <canvas id="errorChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-12 dashboard-widget-col" data-widget-id="lp_table">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h6 class="mb-0">Recent local predictions</h6>
                    <button class="btn btn-outline-secondary btn-sm" id="exportCsvBtn">
                        <i class="material-icons align-middle me-1" style="font-size: 16px;">download</i>
                        Export CSV
                    </button>
                </div>
                <div class="card-body table-responsive" style="max-height: 360px;">
                    <table class="table table-sm table-hover mb-0 analytics-table">
                        <thead>
                            <tr>
                                <th>Prediction time</th>
                                <th>Trend</th>
                                <th class="text-end">Predicted</th>
                                <th class="text-end">Matched observation</th>
                                <th>Obs change</th>
                                <th class="text-end">Abs error</th>
                            </tr>
                        </thead>
                        <tbody id="predictionRows">
                            <tr><td colspan="6" class="text-muted">Loading...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="loadingOverlay" class="loading-overlay" aria-hidden="true">
    <div class="loading-card">
        <div class="loading-title" id="loadingTitle">Loading local predictions...</div>
        <div class="loading-progress">
            <div id="loadingProgressBar" class="loading-progress-bar"></div>
        </div>
        <div class="loading-meta">
            <span id="loadingStep">Preparing data...</span>
            <strong id="loadingPercent">0%</strong>
        </div>
    </div>
</div>

<div class="toast-container position-fixed bottom-0 end-0 p-3">
    <div id="statusToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-header">
            <strong class="me-auto">Satori</strong>
            <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body" id="toastMessage"></div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
let predictionsChart = null;
let errorChart = null;
let currentStream = '';
let allStreams = [];
let loadingHideTimer = null;
let currentRangeDays = '10';
const localPredictionsLayoutStorageKey = 'satori-local-predictions-layout-v1';
let currentTableRows = [];

function showToast(message, isError = false) {
    const toast = document.getElementById('statusToast');
    const toastBody = document.getElementById('toastMessage');
    toastBody.textContent = message;
    toastBody.className = 'toast-body ' + (isError ? 'text-danger' : 'text-success');
    const bsToast = new bootstrap.Toast(toast);
    bsToast.show();
}

function showLoading(message = 'Loading local predictions...', step = 'Preparing data...', percent = 0) {
    const overlay = document.getElementById('loadingOverlay');
    const title = document.getElementById('loadingTitle');
    const stepEl = document.getElementById('loadingStep');
    const percentEl = document.getElementById('loadingPercent');
    const bar = document.getElementById('loadingProgressBar');

    if (loadingHideTimer) {
        clearTimeout(loadingHideTimer);
        loadingHideTimer = null;
    }

    overlay.style.display = 'flex';
    overlay.setAttribute('aria-hidden', 'false');
    title.textContent = message;
    stepEl.textContent = step;
    percentEl.textContent = `${Math.max(0, Math.min(100, percent))}%`;
    bar.style.width = `${Math.max(0, Math.min(100, percent))}%`;
}

function updateLoading(step, percent) {
    const stepEl = document.getElementById('loadingStep');
    const percentEl = document.getElementById('loadingPercent');
    const bar = document.getElementById('loadingProgressBar');
    stepEl.textContent = step;
    percentEl.textContent = `${Math.max(0, Math.min(100, percent))}%`;
    bar.style.width = `${Math.max(0, Math.min(100, percent))}%`;
}

function hideLoading() {
    updateLoading('Done', 100);
    loadingHideTimer = setTimeout(() => {
        const overlay = document.getElementById('loadingOverlay');
        overlay.style.display = 'none';
        overlay.setAttribute('aria-hidden', 'true');
        loadingHideTimer = null;
    }, 220);
}

function saveLocalPredictionsLayout() {
    const row = document.getElementById('localPredictionsLayoutRow');
    if (!row) return;
    const order = Array.from(row.querySelectorAll('.dashboard-widget-col'))
        .map((el) => el.dataset.widgetId)
        .filter(Boolean);
    localStorage.setItem(localPredictionsLayoutStorageKey, JSON.stringify(order));
}

function applyLocalPredictionsLayout() {
    const row = document.getElementById('localPredictionsLayoutRow');
    if (!row) return;
    const raw = localStorage.getItem(localPredictionsLayoutStorageKey);
    if (!raw) return;
    let order = null;
    try {
        order = JSON.parse(raw);
    } catch (e) {
        return;
    }
    if (!Array.isArray(order)) return;

    const map = new Map(Array.from(row.querySelectorAll('.dashboard-widget-col')).map((el) => [el.dataset.widgetId, el]));
    order.forEach((id) => {
        const el = map.get(id);
        if (el) row.appendChild(el);
    });
    map.forEach((el) => {
        if (!order.includes(el.dataset.widgetId)) row.appendChild(el);
    });
}

function initLocalPredictionsDragDrop() {
    const row = document.getElementById('localPredictionsLayoutRow');
    if (!row || typeof Sortable === 'undefined') return;
    Sortable.create(row, {
        animation: 180,
        easing: 'cubic-bezier(0.22, 1, 0.36, 1)',
        draggable: '.dashboard-widget-col',
        ghostClass: 'dragging',
        chosenClass: 'drop-target',
        filter: 'input,textarea,select,button,a,label,.btn,.form-control,.form-select,.dropdown-item',
        preventOnFilter: false,
        onEnd: () => saveLocalPredictionsLayout(),
    });
}

function rangeLabel(daysValue) {
    return daysValue === 'all' ? 'all available history' : `last ${daysValue} day(s)`;
}

function setActiveRangeButton(daysValue) {
    document.querySelectorAll('#rangeButtons [data-days]').forEach((btn) => {
        const isActive = btn.dataset.days === String(daysValue);
        btn.classList.toggle('active', isActive);
        btn.classList.toggle('btn-primary', isActive);
        btn.classList.toggle('btn-outline-light', !isActive);
    });
}

function sliderToSeconds(sliderValue) {
    const percentage = sliderValue / 100.0;
    if (percentage <= 0.0) return 86400;
    if (percentage >= 1.0) return 0;
    return Math.round(86400 * Math.pow(1 - percentage, 7));
}

function secondsToSlider(seconds) {
    if (seconds >= 86400) return 0;
    if (seconds <= 0) return 100;
    const percentage = 1 - Math.pow(seconds / 86400, 1 / 7);
    return Math.round(percentage * 100);
}

function formatDelay(seconds) {
    if (seconds === 0) return "Continuous";
    if (seconds < 60) return `${seconds} seconds`;
    if (seconds < 3600) return `${Math.round(seconds / 60)} minutes`;
    if (seconds < 86400) return `${Math.round(seconds / 3600)} hours`;
    return `${Math.round(seconds / 86400)} days`;
}

function updateTrainingDelayLabel(sliderValue) {
    const seconds = sliderToSeconds(sliderValue);
    document.getElementById('trainingDelayLabel').textContent = formatDelay(seconds);
}

async function setTrainingDelay(sliderValue) {
    const seconds = sliderToSeconds(sliderValue);
    try {
        const response = await fetch('/api/engine/training-delay', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ delay_seconds: seconds }),
        });
        if (response.ok) {
            showToast(`Training frequency updated: ${formatDelay(seconds)}`);
        } else {
            showToast('Failed to update training frequency', true);
        }
    } catch (error) {
        console.error('Error setting training delay:', error);
        showToast('Failed to update training frequency', true);
    }
}

async function loadTrainingDelay() {
    try {
        const response = await fetch('/api/engine/training-delay');
        const result = await response.json();
        if (response.ok && result.delay_seconds !== undefined) {
            const sliderValue = secondsToSlider(result.delay_seconds);
            document.getElementById('trainingDelaySlider').value = sliderValue;
            updateTrainingDelayLabel(sliderValue);
        }
    } catch (error) {
        console.error('Error loading training delay:', error);
    }
}

function shortUuid(uuid) {
    if (!uuid || uuid.length < 16) return uuid || '-';
    return `${uuid.slice(0, 8)}...${uuid.slice(-6)}`;
}

function isUuidLike(value) {
    if (!value || typeof value !== 'string') return false;
    return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value);
}

function parseTimestamp(ts) {
    if (typeof ts === 'number') {
        const value = ts > 1e12 ? ts : ts * 1000;
        return new Date(value);
    }
    if (typeof ts === 'string') {
        const numeric = Number(ts);
        if (!Number.isNaN(numeric)) {
            const value = numeric > 1e12 ? numeric : numeric * 1000;
            return new Date(value);
        }
    }
    return new Date(ts);
}

function formatDateTime(ts) {
    const date = parseTimestamp(ts);
    if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
        return String(ts);
    }
    return date.toLocaleString(undefined, {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false,
    });
}

function formatNumber(value, decimals = 4) {
    if (value === null || value === undefined || Number.isNaN(Number(value))) return '-';
    return Number(value).toFixed(decimals);
}

function formatSigned(value, decimals = 4) {
    if (value === null || value === undefined || Number.isNaN(Number(value))) return '-';
    const n = Number(value);
    if (Math.abs(n) < 1e-12) return '0.0000';
    return `${n > 0 ? '+' : ''}${n.toFixed(decimals)}`;
}

function setStatus(message, type = 'secondary') {
    const box = document.getElementById('statusBox');
    box.className = `mt-3 alert alert-${type} mb-0`;
    box.textContent = message;
}

async function fetchJson(url) {
    const response = await fetch(url);
    const payload = await response.json();
    if (!response.ok) {
        throw new Error(payload.error || `Request failed: ${response.status}`);
    }
    return payload;
}

function getStreamDisplayName(stream, index = 0) {
    if (!stream) return `Stream ${index + 1}`;
    if (stream.stream_display_name) return stream.stream_display_name;
    const name = (stream.stream_name || '').trim();
    if (name && !isUuidLike(name)) return name;
    return `Stream ${index + 1}`;
}

function updateStreamMeta(stream) {
    const meta = document.getElementById('streamMeta');
    if (!stream) {
        meta.textContent = '-';
        return;
    }
    const display = getStreamDisplayName(stream);
    meta.innerHTML = `
        <span class="me-3"><strong>${display}</strong></span>
        <span class="me-3">Stream UUID: <span class="mono">${shortUuid(stream.stream_uuid)}</span></span>
        <span>Prediction UUID: <span class="mono">${shortUuid(stream.prediction_stream_uuid)}</span></span>
    `;
}

function updateStreamDropdownLabel() {
    const stream = allStreams.find((s) => s.stream_uuid === currentStream);
    const label = document.getElementById('streamDropdownLabel');
    if (!label) return;
    label.textContent = stream ? getStreamDisplayName(stream) : 'Select stream';
}

function renderStreamDropdownOptions(filterText = '') {
    const list = document.getElementById('streamDropdownList');
    const select = document.getElementById('streamSelect');
    if (!list || !select) return;

    const q = (filterText || '').trim().toLowerCase();
    const ordered = allStreams.slice().sort((a, b) => {
        const an = getStreamDisplayName(a).toLowerCase();
        const bn = getStreamDisplayName(b).toLowerCase();
        return an.localeCompare(bn);
    });
    const filtered = q
        ? ordered.filter((s) => getStreamDisplayName(s).toLowerCase().includes(q))
        : ordered;

    list.innerHTML = '';
    if (!filtered.length) {
        list.innerHTML = '<div class="text-muted small p-2">No matching streams</div>';
        return;
    }

    filtered.forEach((stream, index) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = `dropdown-item stream-option ${stream.stream_uuid === currentStream ? 'active' : ''}`;
        btn.innerHTML = `
            <div class="title">${getStreamDisplayName(stream, index)}</div>
            <div class="meta">${stream.stream_name ? stream.stream_name : 'Local prediction stream'}</div>
        `;
        btn.addEventListener('click', async () => {
            currentStream = stream.stream_uuid;
            select.value = currentStream;
            updateStreamDropdownLabel();
            updateStreamMeta(stream);
            renderStreamDropdownOptions(document.getElementById('streamSearchInput')?.value || '');
            const dropdownBtn = document.getElementById('streamDropdownBtn');
            if (dropdownBtn) {
                bootstrap.Dropdown.getOrCreateInstance(dropdownBtn).hide();
            }
            await loadPerformance();
        });
        list.appendChild(btn);
    });
}

async function loadStreams() {
    const select = document.getElementById('streamSelect');
    const dropdownBtn = document.getElementById('streamDropdownBtn');
    select.disabled = true;
    if (dropdownBtn) dropdownBtn.disabled = true;
    setStatus('Loading streams...', 'secondary');
    showLoading('Loading local predictions...', 'Fetching stream list...', 15);

    try {
        const data = await fetchJson('/api/engine/streams');
        updateLoading('Stream list ready', 45);
        const streams = data.streams || [];
        allStreams = streams;
        document.getElementById('activeStreamsCount').textContent = data.active_model_count || 0;
        document.getElementById('predictions24hTotal').textContent = data.predictions_24h_total || 0;

        select.innerHTML = '';
        if (streams.length === 0) {
            select.innerHTML = '<option value="">No local streams found</option>';
            renderStreamDropdownOptions('');
            updateStreamDropdownLabel();
            updateMetrics({}, [], [], []);
            renderRows([], []);
            updateStreamMeta(null);
            setStatus('No local streams available yet.', 'warning');
            hideLoading();
            return;
        }

        streams.forEach((stream, index) => {
            const option = document.createElement('option');
            option.value = stream.stream_uuid;
            option.textContent = getStreamDisplayName(stream, index);
            select.appendChild(option);
        });

        if (currentStream && streams.some((s) => s.stream_uuid === currentStream)) {
            select.value = currentStream;
        } else {
            currentStream = streams[0].stream_uuid;
            select.value = currentStream;
        }

        updateStreamMeta(streams.find((s) => s.stream_uuid === select.value));
        updateStreamDropdownLabel();
        renderStreamDropdownOptions(document.getElementById('streamSearchInput')?.value || '');
        updateLoading('Loading selected stream performance...', 62);
        await loadPerformance();
    } catch (error) {
        setStatus(`Failed to load streams: ${error.message}`, 'danger');
        select.innerHTML = '<option value="">Stream load failed</option>';
        hideLoading();
    } finally {
        select.disabled = false;
        if (dropdownBtn) dropdownBtn.disabled = false;
    }
}

function updateMetrics(stats, observations, predictions, accuracy) {
    document.getElementById('obsCount').textContent = observations.length;
    document.getElementById('predCount').textContent = predictions.length;
    document.getElementById('avgAbsError').textContent = stats.avg_abs_error !== undefined
        ? formatNumber(stats.avg_abs_error, 4)
        : '-';
    document.getElementById('accuracyPct').textContent = stats.accuracy_pct !== undefined
        ? `${formatNumber(stats.accuracy_pct, 2)}%`
        : '-';
}

function renderPredictionsChart(observations, predictions) {
    const ctx = document.getElementById('predictionsChart');
    if (predictionsChart) {
        predictionsChart.destroy();
    }

    predictionsChart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [
                {
                    label: 'Observations',
                    data: observations.map((o) => ({ x: parseTimestamp(o.ts), y: Number(o.value) })),
                    borderColor: '#22c55e',
                    backgroundColor: 'rgba(34, 197, 94, 0.2)',
                    tension: 0.2,
                    pointRadius: 2,
                },
                {
                    label: 'Predictions',
                    data: predictions.map((p) => ({ x: parseTimestamp(p.ts), y: Number(p.value) })),
                    borderColor: '#3b82f6',
                    backgroundColor: 'rgba(59, 130, 246, 0.2)',
                    tension: 0.2,
                    pointRadius: 2,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: { type: 'time', time: { tooltipFormat: 'yyyy-MM-dd HH:mm' } },
                y: { ticks: { maxTicksLimit: 8 } }
            }
        }
    });
}

function renderErrorChart(accuracy) {
    const ctx = document.getElementById('errorChart');
    if (errorChart) {
        errorChart.destroy();
    }

    errorChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: accuracy.map((a) => parseTimestamp(a.ts)),
            datasets: [{
                label: 'Absolute error',
                data: accuracy.map((a) => Number(a.abs_error)),
                backgroundColor: 'rgba(244, 63, 94, 0.6)',
                borderColor: '#f43f5e',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: { type: 'time', time: { tooltipFormat: 'yyyy-MM-dd HH:mm' } },
                y: { beginAtZero: true }
            }
        }
    });
}

function renderRows(predictions, accuracy) {
    const tbody = document.getElementById('predictionRows');
    if (!predictions.length) {
        currentTableRows = [];
        tbody.innerHTML = '<tr><td colspan="6" class="text-muted">No local predictions found.</td></tr>';
        return;
    }

    const accuracyByTs = new Map(accuracy.map((a) => [String(a.ts), a]));
    const chronological = predictions
        .slice()
        .sort((a, b) => parseTimestamp(a.ts) - parseTimestamp(b.ts))
        .map((prediction) => {
            const item = accuracyByTs.get(String(prediction.ts));
            return {
                prediction_ts: prediction.ts,
                predicted: Number(prediction.value),
                matched_observation: item && item.actual !== undefined ? Number(item.actual) : null,
                abs_error: item && item.abs_error !== undefined ? Number(item.abs_error) : null,
                obs_change: null,
                trend: 'flat',
            };
        });

    for (let i = 0; i < chronological.length; i += 1) {
        const curr = chronological[i];
        const prev = chronological[i - 1];
        if (!curr || curr.matched_observation === null || !prev || prev.matched_observation === null) {
            curr.obs_change = null;
            curr.trend = 'flat';
            continue;
        }
        curr.obs_change = curr.matched_observation - prev.matched_observation;
        if (curr.obs_change > 0) curr.trend = 'up';
        else if (curr.obs_change < 0) curr.trend = 'down';
        else curr.trend = 'flat';
    }

    currentTableRows = chronological.slice();

    const rows = chronological
        .slice()
        .reverse()
        .slice(0, 120)
        .map((row) => {
            const trendIcon = row.trend === 'up'
                ? '<span class="analytic-pill up"><i class="material-icons" style="font-size:14px;">north</i>Up</span>'
                : row.trend === 'down'
                    ? '<span class="analytic-pill down"><i class="material-icons" style="font-size:14px;">south</i>Down</span>'
                    : '<span class="analytic-pill flat"><i class="material-icons" style="font-size:14px;">remove</i>Flat</span>';

            const changeClass = row.obs_change > 0 ? 'obs-change-up' : row.obs_change < 0 ? 'obs-change-down' : 'obs-change-flat';
            const changeValue = row.obs_change === null ? '-' : formatSigned(row.obs_change, 4);
            const errorPct = (row.abs_error !== null && row.matched_observation)
                ? Math.abs((row.abs_error / row.matched_observation) * 100)
                : null;
            const errorClass = errorPct === null ? 'mid' : errorPct < 0.8 ? 'low' : errorPct < 2.0 ? 'mid' : 'high';
            const errorDisplay = row.abs_error === null
                ? '-'
                : `<span class="delta-chip ${errorClass}">${formatNumber(row.abs_error, 4)}</span>`;

            return `
                <tr>
                    <td class="time-cell" title="${row.prediction_ts}">${formatDateTime(row.prediction_ts)}</td>
                    <td>${trendIcon}</td>
                    <td class="numeric-cell">${formatNumber(row.predicted, 4)}</td>
                    <td class="numeric-cell">${row.matched_observation === null ? '<span class="subtle-value">-</span>' : formatNumber(row.matched_observation, 4)}</td>
                    <td class="${changeClass}">${changeValue}</td>
                    <td class="numeric-cell">${errorDisplay}</td>
                </tr>
            `;
        });

    tbody.innerHTML = rows.join('');
}

function exportCurrentTableToCsv() {
    if (!currentTableRows.length) {
        showToast('No prediction rows to export', true);
        return;
    }

    const headers = ['prediction_time', 'trend', 'predicted', 'matched_observation', 'observation_change', 'abs_error'];
    const csvRows = [headers.join(',')];

    currentTableRows.forEach((row) => {
        const fields = [
            `"${String(row.prediction_ts).replace(/"/g, '""')}"`,
            row.trend,
            row.predicted ?? '',
            row.matched_observation ?? '',
            row.obs_change ?? '',
            row.abs_error ?? '',
        ];
        csvRows.push(fields.join(','));
    });

    const stream = allStreams.find((s) => s.stream_uuid === currentStream);
    const streamName = (getStreamDisplayName(stream) || 'stream').replace(/[^a-z0-9_\-]+/gi, '_').toLowerCase();
    const now = new Date();
    const stamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const fileName = `local_predictions_${streamName}_${currentRangeDays}d_${stamp}.csv`;

    const blob = new Blob([csvRows.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = fileName;
    document.body.appendChild(link);
    link.click();
    link.remove();
    URL.revokeObjectURL(url);
    showToast(`CSV exported (${currentTableRows.length} rows)`);
}

async function loadPerformance() {
    const select = document.getElementById('streamSelect');
    const streamUuid = select.value;
    if (!streamUuid) {
        return;
    }

    currentStream = streamUuid;
    setStatus('Loading predictions for selected stream...', 'secondary');
    showLoading('Loading local predictions...', `Fetching ${rangeLabel(currentRangeDays)}...`, 70);

    try {
        const data = await fetchJson(
            `/api/engine/performance?stream_uuid=${encodeURIComponent(streamUuid)}&days=${encodeURIComponent(currentRangeDays)}`
        );
        updateLoading('Processing and rendering charts...', 88);
        const observations = data.observations || [];
        const predictions = data.predictions || [];
        const accuracy = data.accuracy || [];
        const stats = data.stats || {};
        const stream = allStreams.find((s) => s.stream_uuid === streamUuid);

        updateMetrics(stats, observations, predictions, accuracy);
        updateStreamMeta(stream);
        renderPredictionsChart(observations, predictions);
        renderErrorChart(accuracy);
        renderRows(predictions, accuracy);

        setStatus(
            `Loaded ${predictions.length} predictions and ${observations.length} observations for ${getStreamDisplayName(stream)} (${shortUuid(streamUuid)}), window: ${rangeLabel(currentRangeDays)}.`,
            'success'
        );
        hideLoading();
    } catch (error) {
        setStatus(`Failed to load performance data: ${error.message}`, 'danger');
        hideLoading();
    }
}

document.addEventListener('DOMContentLoaded', async () => {
    applyLocalPredictionsLayout();
    initLocalPredictionsDragDrop();

    setActiveRangeButton(currentRangeDays);
    document.querySelectorAll('#rangeButtons [data-days]').forEach((btn) => {
        btn.addEventListener('click', async () => {
            const nextRange = btn.dataset.days;
            if (nextRange === currentRangeDays) {
                return;
            }
            currentRangeDays = nextRange;
            setActiveRangeButton(currentRangeDays);
            await loadPerformance();
        });
    });

    document.getElementById('refreshBtn').addEventListener('click', async () => {
        await loadPerformance();
    });
    document.getElementById('exportCsvBtn').addEventListener('click', exportCurrentTableToCsv);
    document.getElementById('streamSearchInput').addEventListener('input', (event) => {
        renderStreamDropdownOptions(event.target.value || '');
    });

    await loadTrainingDelay();
    await loadStreams();
});
</script>
{% endblock %}
