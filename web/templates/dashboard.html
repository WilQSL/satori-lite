{% extends "base.html" %}

{% block title %}Satori - {{ 'P2P' if page_mode == 'p2p' else 'Dashboard' }}{% endblock %}
{% block extra_css %}
{% if page_mode == 'dashboard' %}
<style>
    #p2p,
    #p2pLayoutRow {
        display: none !important;
    }
</style>
{% elif page_mode == 'p2p' %}
<style>
    #dashboardLayoutRow {
        display: none !important;
    }
</style>
{% endif %}
{% endblock %}

{% block content %}
{% include 'partials/navbar.html' %}

<!-- Import Wallet Modal -->
<div class="modal fade" id="importWalletModal" tabindex="-1" aria-labelledby="importWalletModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content" style="background: var(--bg-card); border: 1px solid var(--border-color);">
            <div class="modal-header" style="border-bottom: 1px solid var(--border-color);">
                <h5 class="modal-title" id="importWalletModalLabel">
                    <i class="material-icons align-middle me-2">upload_file</i>
                    Import Wallet
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" style="filter: invert(1);"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-warning">
                    <strong>Warning:</strong> Importing a wallet will replace your current wallet and restart the container.
                    Make sure you have backed up your current wallet first!
                </div>

                <div class="mb-3">
                    <label class="form-label">Select Wallet Folder</label>
                    <input type="file"
                           class="form-control"
                           id="walletFolderInputModal"
                           webkitdirectory
                           directory
                           multiple
                           accept=".yaml,.yml">
                    <small class="form-text text-muted">
                        Select the "wallet" folder containing wallet.yaml and vault.yaml
                    </small>
                </div>

                <div id="importFileListModal" class="mb-3" style="display: none;">
                    <label class="form-label">Files to Import:</label>
                    <ul id="importFileListItemsModal" class="small"></ul>
                </div>

                <div id="importResultModal" class="mt-3" style="display: none;"></div>
            </div>
            <div class="modal-footer" style="border-top: 1px solid var(--border-color);">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="importWalletFromModal()" id="importWalletBtnModal" disabled>
                    <i class="material-icons align-middle me-1">upload</i>
                    Import Wallet & Restart
                </button>
            </div>
        </div>
    </div>
</div>

<div class="container-fluid py-4">
    <div class="row g-4" id="dashboardLayoutRow">
        <!-- Wallet Section -->
        <div class="col-12 dashboard-widget-col" data-widget-id="wallet" draggable="true">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">account_balance_wallet</i>
                        Wallet
                    </h5>
                    <div class="d-flex align-items-center gap-2">
                        <a href="#" class="btn btn-outline-secondary btn-sm" onclick="toggleIdentityWallet(); return false;">
                            <i class="material-icons align-middle" style="font-size: 16px;">badge</i>
                            Identity
                        </a>
                        <span class="text-muted drag-handle" title="Drag to reorder">
                            <i class="material-icons align-middle" style="font-size: 16px;">drag_indicator</i>
                        </span>
                    </div>
                </div>
                <div class="card-body">
                    <div class="row">
                        <!-- Left side: QR Code and Address -->
                        <div class="col-lg-6 mb-4 mb-lg-0">
                            <div class="text-center mb-3">
                                <div id="walletQrCode" class="mb-3" style="display: inline-block; background: white; padding: 10px; border-radius: 10px;">
                                    <p class="text-muted mb-0">Loading QR code...</p>
                                </div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Wallet Address</label>
                                <div class="input-group">
                                    <input type="text" class="form-control" id="walletAddress" readonly placeholder="Loading...">
                                    <button class="btn btn-outline-secondary" onclick="copyToClipboard('walletAddress')" title="Copy to clipboard">
                                        <i class="material-icons align-middle">content_copy</i>
                                    </button>
                                </div>
                            </div>
                            <div class="text-center">
                                <p id="showPrivateKeyBtn" class="text-danger mb-2" style="cursor: pointer;" onclick="togglePrivateKey()">
                                    <i class="material-icons align-middle" style="font-size: 18px;">visibility</i>
                                    Show Private Key
                                </p>
                                <div id="privateKeySection" style="display: none;">
                                    <p class="text-muted mb-2" style="cursor: pointer;" onclick="togglePrivateKey()">
                                        <i class="material-icons align-middle" style="font-size: 18px;">visibility_off</i>
                                        Hide Private Key
                                    </p>
                                    <div class="alert alert-warning" style="word-break: break-all;">
                                        <small><strong>Private Key:</strong></small><br>
                                        <code id="walletPrivateKey">Loading...</code>
                                    </div>
                                    <button class="btn btn-outline-secondary btn-sm" onclick="copyPrivateKey()">
                                        <i class="material-icons align-middle" style="font-size: 16px;">content_copy</i>
                                        Copy Private Key
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Right side: Send Tokens -->
                        <div class="col-lg-6">
                            <h6 class="mb-3">
                                <i class="material-icons align-middle me-1">send</i>
                                Send SATORI
                            </h6>
                            <div class="mb-3">
                                <label class="form-label">Send From</label>
                                <div class="d-flex gap-3">
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="sendSource" id="sendFromVault" value="vault" checked>
                                        <label class="form-check-label" for="sendFromVault">
                                            Vault <small class="text-muted" id="vaultBalanceLabel">(--)</small>
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="sendSource" id="sendFromWallet" value="wallet">
                                        <label class="form-check-label" for="sendFromWallet">
                                            Identity Wallet <small class="text-muted" id="walletBalanceLabel">(--)</small>
                                        </label>
                                    </div>
                                </div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Destination Address</label>
                                <input type="text" class="form-control" id="sendDestAddress" placeholder="Enter destination address (E...)">
                            </div>
                            <div class="row mb-3">
                                <div class="col-8">
                                    <label class="form-label">Amount</label>
                                    <input type="number" class="form-control" id="sendAmount" placeholder="0.00" step="0.00000001" min="0">
                                </div>
                                <div class="col-4">
                                    <label class="form-label">Sweep All</label>
                                    <div class="form-check mt-2">
                                        <input class="form-check-input" type="checkbox" id="sendSweep" onchange="toggleSweepAmount()">
                                        <label class="form-check-label" for="sendSweep">Send All</label>
                                    </div>
                                </div>
                            </div>
                            <button class="btn btn-primary w-100" onclick="sendTransaction()" id="sendBtn">
                                <i class="material-icons align-middle me-1">send</i>
                                Send Transaction
                            </button>
                            <div id="sendResult" class="mt-3" style="display: none;"></div>
                            <p class="text-muted small mt-3 mb-0">
                                Transaction fees will be paid during the send process. They typically amount to no more than 0.25 EVR.
                            </p>
                        </div>
                    </div>

                    <!-- Identity Wallet (Collapsed) -->
                    <div id="identityWalletSection" style="display: none;" class="mt-4 pt-4 border-top">
                        <h6 class="text-muted mb-3">
                            <i class="material-icons align-middle me-1">badge</i>
                            Identity Wallet (for digital identity only - do not send tokens here)
                        </h6>
                        <div class="row">
                            <div class="col-md-6 mb-3 mb-md-0">
                                <label class="form-label small">Identity Address</label>
                                <div class="input-group input-group-sm">
                                    <input type="text" class="form-control" id="identityAddress" readonly placeholder="Loading...">
                                    <button class="btn btn-outline-secondary" onclick="copyToClipboard('identityAddress')" title="Copy">
                                        <i class="material-icons align-middle" style="font-size: 16px;">content_copy</i>
                                    </button>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <label class="form-label small">Identity Private Key</label>
                                <div class="input-group input-group-sm">
                                    <input type="password" class="form-control" id="identityPrivateKey" readonly placeholder="Click to reveal...">
                                    <button class="btn btn-outline-secondary" onclick="toggleIdentityPrivateKey()" title="Show/Hide">
                                        <i class="material-icons align-middle" style="font-size: 16px;" id="identityKeyIcon">visibility</i>
                                    </button>
                                    <button class="btn btn-outline-secondary" onclick="copyIdentityPrivateKey()" title="Copy">
                                        <i class="material-icons align-middle" style="font-size: 16px;">content_copy</i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Balance Section -->
        <div class="col-12 col-lg-6 dashboard-widget-col" data-widget-id="balance" draggable="true">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">account_balance_wallet</i>
                        Balance
                    </h5>
                    <div class="d-flex align-items-center gap-2">
                        <button class="btn btn-sm btn-outline-secondary" onclick="refreshBalance()">
                            <i class="material-icons align-middle" style="font-size: 16px;">refresh</i>
                        </button>
                        <span class="text-muted drag-handle" title="Drag to reorder">
                            <i class="material-icons align-middle" style="font-size: 16px;">drag_indicator</i>
                        </span>
                    </div>
                </div>
                <div class="card-body">
                    <div class="row text-center py-3">
                        <div class="col-md-4 col-6 mb-3 mb-md-0">
                            <h3 id="tokenBalance">
                                <span class="spinner-border spinner-border-sm" role="status"></span>
                            </h3>
                            <p class="text-muted mb-0">SATORI Token</p>
                        </div>
                        <div class="col-md-4 col-6 mb-3 mb-md-0">
                            <h3 id="stakeBalance">
                                <span class="spinner-border spinner-border-sm" role="status"></span>
                            </h3>
                            <p class="text-muted mb-0">SATORI Stake</p>
                        </div>
                        <div class="col-md-4 col-12">
                            <h3 id="evrBalance">
                                <span class="spinner-border spinner-border-sm" role="status"></span>
                            </h3>
                            <p class="text-muted mb-0">Evrmore (EVR)</p>
                        </div>
                    </div>
                    <p id="noEvrWarning" class="text-muted small mb-0 mt-1" style="display: none; opacity: 0.7;">
                        Without EVR in your wallet, larger transaction fees will be paid in SATORI.
                    </p>
                </div>
            </div>
        </div>

        <!-- Reward Address Section -->
        <div class="col-12 col-lg-6 dashboard-widget-col" data-widget-id="reward" draggable="true">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">card_giftcard</i>
                        Reward Address
                    </h5>
                    <span class="text-muted drag-handle" title="Drag to reorder">
                        <i class="material-icons align-middle" style="font-size: 16px;">drag_indicator</i>
                    </span>
                </div>
                <div class="card-body">
                    <div class="mb-3">
                        <label class="form-label">Current Address</label>
                        <input type="text" class="form-control" id="currentRewardAddress" readonly placeholder="Not set">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">New Address</label>
                        <input type="text" class="form-control" id="newRewardAddress" placeholder="Enter new reward address">
                    </div>
                    <button class="btn btn-primary" onclick="setRewardAddress()">Save Address</button>
                </div>
            </div>
        </div>

        <div class="col-12 dashboard-widget-col" data-widget-id="monitoring" draggable="true">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">monitor_heart</i>
                        Neuron Monitoring
                    </h5>
                    <div class="d-flex align-items-center gap-2">
                        <small class="text-muted" id="systemStatsLastUpdate">Waiting for data...</small>
                        <span class="text-muted drag-handle" title="Drag to reorder">
                            <i class="material-icons align-middle" style="font-size: 16px;">drag_indicator</i>
                        </span>
                    </div>
                </div>
                <div class="card-body">
                    <div class="small text-muted mb-3" id="systemHostInfo">Host details unavailable</div>
                    <div class="row g-3">
                        <div class="col-12 col-md-6 col-xl-3">
                            <div class="card h-100">
                                <div class="card-body p-3">
                                    <div class="d-flex justify-content-between align-items-center mb-2">
                                        <span class="small text-muted">CPU</span>
                                        <strong id="systemCpuCurrent">--</strong>
                                    </div>
                                    <div style="height: 120px;">
                                        <canvas id="systemCpuChart"></canvas>
                                    </div>
                                    <div class="small text-muted mt-2">System uptime: <span id="systemUptime">--</span></div>
                                </div>
                            </div>
                        </div>
                        <div class="col-12 col-md-6 col-xl-3">
                            <div class="card h-100">
                                <div class="card-body p-3">
                                    <div class="d-flex justify-content-between align-items-center mb-2">
                                        <span class="small text-muted">Memory</span>
                                        <strong id="systemMemCurrent">--</strong>
                                    </div>
                                    <div style="height: 120px;">
                                        <canvas id="systemMemChart"></canvas>
                                    </div>
                                    <div class="small text-muted mt-2">Process RSS: <span id="systemProcMemCurrent">--</span></div>
                                </div>
                            </div>
                        </div>
                        <div class="col-12 col-md-6 col-xl-3">
                            <div class="card h-100">
                                <div class="card-body p-3">
                                    <div class="d-flex justify-content-between align-items-center mb-2">
                                        <span class="small text-muted">Disk</span>
                                        <strong id="systemDiskCurrent">--</strong>
                                    </div>
                                    <div style="height: 120px;">
                                        <canvas id="systemDiskChart"></canvas>
                                    </div>
                                    <div class="small text-muted mt-2">Root usage trend</div>
                                </div>
                            </div>
                        </div>
                        <div class="col-12 col-md-6 col-xl-3">
                            <div class="card h-100">
                                <div class="card-body p-3">
                                    <div class="d-flex justify-content-between align-items-center mb-2">
                                        <span class="small text-muted">Process CPU</span>
                                        <strong id="systemProcCpuCurrent">--</strong>
                                    </div>
                                    <div style="height: 120px;">
                                        <canvas id="systemProcChart"></canvas>
                                    </div>
                                    <div class="small text-muted mt-2">Threads: <span id="systemThreads">--</span> | Uptime: <span id="systemProcessUptime">--</span></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <div id="p2p" class="row g-4 mt-2">
        <div class="col-12">
            <div class="d-flex align-items-center gap-2">
                <i class="material-icons align-middle">hub</i>
                <h4 class="mb-0">P2P</h4>
            </div>
        </div>
    </div>

    <div class="row g-4 mt-2" id="p2pLayoutRow">
        <!-- Relay Settings Section -->
        <div class="col-12 p2p-widget-col" data-widget-id="relay-settings" draggable="true">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">cell_tower</i>
                        Relay Settings
                    </h5>
                    <span class="text-muted drag-handle" title="Drag to reorder">
                        <i class="material-icons align-middle" style="font-size: 16px;">drag_indicator</i>
                    </span>
                </div>
                <div class="card-body">
                    <div class="mb-3">
                        <label class="form-label">Nostr Public Key</label>
                        <div class="input-group">
                            <input type="text" class="form-control" id="nostrPubkey"
                                   value="{{ nostr_pubkey or 'Not generated' }}" readonly
                                   style="font-family: monospace; font-size: 0.85rem;">
                            <button class="btn btn-outline-secondary" onclick="copyToClipboard('nostrPubkey')" title="Copy">
                                <i class="material-icons align-middle" style="font-size: 16px;">content_copy</i>
                            </button>
                        </div>
                        <small class="form-text text-muted">
                            Set this as NOSTR_PUBKEY in your relay's .env file
                        </small>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Relay URL</label>
                        <input type="text" class="form-control" id="relayUrl"
                               value="{{ relay_url or '' }}"
                               placeholder="wss://your-relay.example.com">
                        <small class="form-text text-muted">
                            WebSocket URL of your Nostr relay (must have NIP-11 configured with your pubkey)
                        </small>
                    </div>
                    <div class="d-flex align-items-center">
                        <button class="btn btn-primary" onclick="registerRelay()">Register Relay</button>
                        <span id="relayStatus" class="ms-3" style="display: none;"></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Active Subscriptions Section -->
        <div class="col-12 p2p-widget-col" data-widget-id="subscriptions" draggable="true">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">playlist_add_check</i>
                        Subscriptions
                    </h5>
                    <div class="d-flex align-items-center gap-2">
                        <button id="subsToggleInactive" class="btn btn-sm btn-outline-secondary" onclick="toggleInactiveSubs()">Show Inactive</button>
                        <span class="text-muted drag-handle" title="Drag to reorder">
                            <i class="material-icons align-middle" style="font-size: 16px;">drag_indicator</i>
                        </span>
                    </div>
                </div>
                <div class="card-body">
                    <div id="subsEmpty" class="text-center text-muted py-3">
                        No active subscriptions.
                    </div>
                    <div id="subsTable" style="display: none;">
                        <div class="table-responsive">
                            <table class="table table-sm table-hover mb-0">
                                <thead>
                                    <tr>
                                        <th>Stream</th>
                                        <th>Relay</th>
                                        <th>Cadence</th>
                                        <th>Status</th>
                                        <th></th>
                                    </tr>
                                </thead>
                                <tbody id="subsList"></tbody>
                            </table>
                        </div>
                    </div>
                    <!-- Observations drawer -->
                    <div id="obsDrawer" style="display: none; border-top: 1px solid var(--bs-border-color);">
                        <div class="p-3">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <h6 class="mb-0" id="obsDrawerTitle">Observations</h6>
                                <button class="btn btn-sm btn-outline-secondary" onclick="closeObsDrawer()">Close</button>
                            </div>
                            <div id="obsChartContainer" style="display: none; max-height: 250px; margin-bottom: 12px;">
                                <canvas id="obsChart"></canvas>
                            </div>
                            <ul class="nav nav-tabs mb-2" id="obsDrawerTabs">
                                <li class="nav-item">
                                    <a class="nav-link active" href="#" onclick="switchObsTab('observations', this); return false;">Observations</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" href="#" onclick="switchObsTab('predictions', this); return false;">Predictions</a>
                                </li>
                            </ul>
                            <div class="table-responsive">
                                <table class="table table-sm table-hover mb-0">
                                    <thead id="obsDrawerHead">
                                        <tr>
                                            <th>Seq</th>
                                            <th>Observed At</th>
                                            <th>Received At</th>
                                            <th>Value</th>
                                        </tr>
                                    </thead>
                                    <tbody id="obsDrawerBody"></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Publications Section -->
        <div class="col-12 p2p-widget-col" data-widget-id="publications" draggable="true">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">publish</i>
                        Publications
                    </h5>
                    <div class="d-flex align-items-center gap-2">
                        <div class="d-flex gap-2">
                            <button class="btn btn-sm btn-outline-primary" onclick="resetDataSourceForm(); toggleDataSourceForm()">New Data Source</button>
                            <button class="btn btn-sm btn-outline-success" onclick="downloadCsvTemplate()">CSV Template</button>
                            <label class="btn btn-sm btn-outline-success mb-0">
                                Upload CSV
                                <input type="file" id="csvUpload" accept=".csv" style="display:none;" onchange="uploadCsv(this)">
                            </label>
                            <button id="pubsToggleInactive" class="btn btn-sm btn-outline-secondary" onclick="toggleInactivePubs()">Show Inactive</button>
                        </div>
                        <span class="text-muted drag-handle" title="Drag to reorder">
                            <i class="material-icons align-middle" style="font-size: 16px;">drag_indicator</i>
                        </span>
                    </div>
                </div>
                <div class="card-body">
                    <!-- New Data Source Form -->
                    <div id="dataSourceForm" style="display: none;" class="mb-3 p-3 border rounded">
                        <h6 class="mb-3" id="dsFormTitle">New Data Source</h6>
                        <div class="row g-2 mb-2">
                            <div class="col-md-4">
                                <label class="form-label form-label-sm">Stream Name</label>
                                <input type="text" id="dsStreamName" class="form-control form-control-sm" placeholder="btc-price">
                            </div>
                            <div class="col-md-4">
                                <label class="form-label form-label-sm">Display Name</label>
                                <input type="text" id="dsName" class="form-control form-control-sm" placeholder="Bitcoin Price">
                            </div>
                            <div class="col-md-4">
                                <label class="form-label form-label-sm">Description</label>
                                <input type="text" id="dsDescription" class="form-control form-control-sm" placeholder="BTC/USD spot price">
                            </div>
                        </div>
                        <div class="row g-2 mb-2">
                            <div class="col-md-6">
                                <label class="form-label form-label-sm">URL <small class="text-muted">(leave empty for external push)</small></label>
                                <input type="text" id="dsUrl" class="form-control form-control-sm" placeholder="https://api.example.com/price" oninput="toggleFetchFields()">
                            </div>
                            <div class="col-md-2" id="dsMethodGroup">
                                <label class="form-label form-label-sm">Method</label>
                                <select id="dsMethod" class="form-select form-select-sm">
                                    <option value="GET">GET</option>
                                    <option value="POST">POST</option>
                                </select>
                            </div>
                            <div class="col-md-3" id="dsCadenceGroup">
                                <label class="form-label form-label-sm">Cadence <small class="text-muted">(optional)</small></label>
                                <div class="input-group input-group-sm">
                                    <input type="number" id="dsCadenceMin" class="form-control form-control-sm" value="" min="15" placeholder="—">
                                    <span class="input-group-text">min</span>
                                    <select id="dsCadencePreset" class="form-select form-select-sm" onchange="applyCadencePreset()">
                                        <option value="">Presets</option>
                                        <option value="15">15 min</option>
                                        <option value="30">30 min</option>
                                        <option value="60">1 hour</option>
                                        <option value="240">4 hours</option>
                                        <option value="1440">1 day</option>
                                        <option value="10080">1 week</option>
                                        <option value="43200">1 month</option>
                                        <option value="525600">1 year</option>
                                    </select>
                                </div>
                            </div>
                            <div class="col-md-2" id="dsHeadersGroup">
                                <label class="form-label form-label-sm">Headers (JSON)</label>
                                <input type="text" id="dsHeaders" class="form-control form-control-sm" placeholder='{"Authorization": "..."}'>
                            </div>
                        </div>
                        <div class="row g-2 mb-2" id="dsParserRow">
                            <div class="col-md-3">
                                <label class="form-label form-label-sm">Parser Type</label>
                                <select id="dsParserType" class="form-select form-select-sm" onchange="toggleParserInput()">
                                    <option value="json_path">JSON Path</option>
                                    <option value="python">Python Function</option>
                                </select>
                            </div>
                            <div class="col-md-9" id="dsParserJsonPathGroup">
                                <label class="form-label form-label-sm">JSON Path</label>
                                <input type="text" id="dsParserJsonPath" class="form-control form-control-sm" placeholder="data.price">
                            </div>
                            <div class="col-md-9" id="dsParserPythonGroup" style="display: none;">
                                <label class="form-label form-label-sm">Python Function <small class="text-muted">(receives <code>text</code>, return the value)</small></label>
                                <textarea id="dsParserPython" class="form-control form-control-sm font-monospace" rows="4" placeholder="import json&#10;data = json.loads(text)&#10;return data['price']"></textarea>
                            </div>
                        </div>
                        <div id="dsExternalHint" style="display: none;" class="mb-2">
                            <small class="text-muted">
                                No URL — this stream accepts data via <code>POST /api/network/publish</code>
                                with <code>{\"stream_name\": \"...\", \"value\": \"...\"}</code>
                            </small>
                        </div>
                        <div class="d-flex gap-2 mb-2">
                            <button class="btn btn-sm btn-outline-info" onclick="testDataSource(this)">Test</button>
                            <button class="btn btn-sm btn-primary" onclick="saveDataSource(this)">Save</button>
                            <button class="btn btn-sm btn-outline-secondary" onclick="toggleDataSourceForm(false)">Cancel</button>
                            <span id="dsError" class="text-danger small align-self-center"></span>
                        </div>
                        <div id="dsTestResults" style="display: none;">
                            <div class="row g-2">
                                <div class="col-md-8">
                                    <label class="form-label form-label-sm">Response <small class="text-muted">(click a value to select it)</small></label>
                                    <div id="dsTestTree" class="border rounded p-2 bg-light" style="max-height: 280px; overflow: auto; font-size: 0.8rem;"></div>
                                </div>
                                <div class="col-md-4">
                                    <label class="form-label form-label-sm">Extracted Value</label>
                                    <div id="dsTestValue" class="border rounded p-2 bg-light font-monospace" style="min-height: 40px;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="pubsEmpty" class="text-center text-muted py-3">
                        No publications yet.
                    </div>
                    <div id="pubsTable" style="display: none;">
                        <div class="table-responsive">
                            <table class="table table-sm table-hover mb-0">
                                <thead>
                                    <tr>
                                        <th>Stream</th>
                                        <th>Source</th>
                                        <th>Cadence</th>
                                        <th>Seq</th>
                                        <th>Status</th>
                                        <th></th>
                                    </tr>
                                </thead>
                                <tbody id="pubsList"></tbody>
                            </table>
                        </div>
                    </div>
                    <!-- Publication data drawer -->
                    <div id="pubDrawer" style="display: none; border-top: 1px solid var(--bs-border-color);">
                        <div class="p-3">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <h6 class="mb-0" id="pubDrawerTitle">Publication Data</h6>
                                <button class="btn btn-sm btn-outline-secondary" onclick="closePubDrawer()">Close</button>
                            </div>
                            <div id="pubChartContainer" style="display: none; max-height: 250px; margin-bottom: 12px;">
                                <canvas id="pubChart"></canvas>
                            </div>
                            <ul class="nav nav-tabs mb-2" id="pubDrawerTabs">
                                <li class="nav-item">
                                    <a class="nav-link active" href="#" onclick="switchPubTab('observations', this); return false;">Observations</a>
                                </li>
                                <li class="nav-item">
                                    <a class="nav-link" href="#" onclick="switchPubTab('predictions', this); return false;">Predictions</a>
                                </li>
                            </ul>
                            <div class="table-responsive">
                                <table class="table table-sm table-hover mb-0">
                                    <thead id="pubDrawerHead">
                                        <tr>
                                            <th>Seq</th>
                                            <th>Observed At</th>
                                            <th>Received At</th>
                                            <th>Value</th>
                                        </tr>
                                    </thead>
                                    <tbody id="pubDrawerBody"></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Relays Section -->
        <div class="col-12 p2p-widget-col" data-widget-id="relays" draggable="true">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">rss_feed</i>
                        Relays
                    </h5>
                    <div class="d-flex align-items-center gap-2">
                        <div class="input-group input-group-sm" style="width: 320px;">
                            <input type="text" id="addRelayInput" class="form-control" placeholder="wss://relay.example.com">
                            <button class="btn btn-outline-primary" onclick="addRelay()">Add</button>
                        </div>
                        <span id="networkStatus" class="badge bg-secondary">Checking...</span>
                        <span class="text-muted drag-handle" title="Drag to reorder">
                            <i class="material-icons align-middle" style="font-size: 16px;">drag_indicator</i>
                        </span>
                    </div>
                </div>
                <div class="card-body p-0">
                    <div id="relaysLoading" class="text-center text-muted py-3">
                        Loading relays...
                    </div>
                    <div id="relaysEmpty" class="text-center text-muted py-3" style="display: none;">
                        No relays found.
                    </div>
                    <div id="relaysTable" style="display: none;">
                        <div class="table-responsive">
                            <table class="table table-sm table-hover mb-0">
                                <thead>
                                    <tr>
                                        <th>Relay URL</th>
                                        <th>Last Active</th>
                                        <th>Source</th>
                                        <th></th>
                                        <th></th>
                                    </tr>
                                </thead>
                                <tbody id="relaysList"></tbody>
                            </table>
                        </div>
                    </div>
                    <!-- Streams drawer -->
                    <div id="relayDrawer" style="display: none; border-top: 1px solid var(--bs-border-color);">
                        <div class="p-3">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <h6 class="mb-0" id="relayDrawerTitle">Streams</h6>
                                <button class="btn btn-sm btn-outline-secondary" onclick="closeRelayDrawer()">Close</button>
                            </div>
                            <div class="table-responsive">
                                <table class="table table-sm table-hover mb-0">
                                    <thead>
                                        <tr>
                                            <th>Stream</th>
                                            <th>Description</th>
                                            <th>Cadence</th>
                                            <th>Price</th>
                                            <th>Tags</th>
                                            <th></th>
                                        </tr>
                                    </thead>
                                    <tbody id="relayDrawerStreams"></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

</div>

<!-- Disclaimer Footer -->
<div class="container-fluid py-3">
    <div class="card">
        <div class="card-header text-center"
             style="cursor: pointer;"
             data-bs-toggle="collapse"
             data-bs-target="#disclaimerCollapse"
             aria-expanded="false"
             aria-controls="disclaimerCollapse">
            <h6 class="mb-0 text-muted">
                <i class="material-icons align-middle me-2" style="font-size: 18px;">info</i>
                Disclaimer of Warranties and Limitation of Liability
            </h6>
        </div>
        <div class="collapse" id="disclaimerCollapse">
            <div class="card-body">
                <div class="disclaimer-content" style="font-size: 0.85rem; line-height: 1.6;">
                    <h6>1. DISCLAIMER OF WARRANTIES</h6>
                    <p><strong>AS IS:</strong> The Satori Neuron software ("Software") is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, whether express or implied, including but not limited to implied warranties of merchantability, fitness for a particular purpose, title, and non-infringement.</p>
                    <p><strong>NO GUARANTEE:</strong> We do not guarantee that the Software will be uninterrupted, error-free, secure, or free of viruses or other harmful components.</p>
                    <p><strong>USER RESPONSIBILITY:</strong> The user is solely responsible for any damage to their device or loss of data that results from the use of the Software.</p>

                    <h6 class="mt-3">2. LIMITATION OF LIABILITY</h6>
                    <p><strong>NO LIABILITY FOR DAMAGES:</strong> In no event shall The Satori Association or its affiliates, officers, directors, employees, agents, or licensors be liable for any indirect, incidental, special, consequential, or punitive damages, or any loss of profits or revenues, whether incurred directly or indirectly, or any loss of data, use, goodwill, or other intangible losses, resulting from:</p>
                    <ul>
                        <li>Your use or inability to use the Software;</li>
                        <li>Any unauthorized access to or use of the Software;</li>
                        <li>Any interruption or cessation of transmission to or from the Software;</li>
                        <li>Any bugs, viruses, trojan horses, or the like that may be transmitted to or through the Software by any third party;</li>
                        <li>Any errors or omissions in any content or for any loss or damage incurred as a result of the use of any content posted, emailed, transmitted, or otherwise made available through the Software, whether based on warranty, contract, tort (including negligence), or any other legal theory, whether or not we have been informed of the possibility of such damage.</li>
                    </ul>

                    <h6 class="mt-3">3. MAXIMUM LIABILITY</h6>
                    <p><strong>LIMITATION CAP:</strong> Our maximum aggregate liability under or in connection with the Software, whether in contract, tort (including negligence), or otherwise, shall in no circumstances exceed the amount paid by you, if any, for accessing or using the Software.</p>

                    <h6 class="mt-3">4. EXCLUSIONS</h6>
                    <p><strong>APPLICABLE LAW:</strong> Some jurisdictions do not allow the exclusion of certain warranties or the limitation or exclusion of liability for incidental or consequential damages. Accordingly, some of the above limitations may not apply to you. In such jurisdictions, our liability will be limited to the fullest extent permitted by applicable law.</p>

                    <h6 class="mt-3">5. INDEMNIFICATION</h6>
                    <p><strong>USER INDEMNITY:</strong> You agree to indemnify, defend, and hold harmless The Satori Association and its affiliates, officers, directors, employees, agents, and licensors from and against any claims, liabilities, damages, losses, and expenses, including, without limitation, reasonable legal and accounting fees, arising out of or in any way connected with your access to or use of the Software, or your violation of these terms.</p>

                    <h6 class="mt-3">6. GOVERNING LAW</h6>
                    <p><strong>SWISS LAW:</strong> This Disclaimer of Warranties and Limitation of Liability shall be governed by and construed in accordance with the laws of Switzerland, without regard to its conflict of laws principles.</p>

                    <h6 class="mt-3">7. DISPUTE RESOLUTION</h6>
                    <p><strong>MEDIATION FIRST:</strong> Any disputes arising under or in connection with this Disclaimer of Warranties and Limitation of Liability shall first be attempted to be resolved through mediation. The parties agree to submit the dispute to a mutually agreed-upon mediator in Switzerland. If mediation fails to resolve the dispute, it shall then be resolved in the courts of Switzerland.</p>

                    <h6 class="mt-3">8. CONTACT INFORMATION</h6>
                    <p>For any inquiries regarding this Disclaimer of Warranties and Limitation of Liability, please contact:</p>
                    <p class="mb-0">
                        <strong>The Satori Association</strong><br>
                        <a href="mailto:disclaimer@satorinet.io">disclaimer@satorinet.io</a>
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Status Messages -->
<div class="position-fixed bottom-0 end-0 p-3" style="z-index: 11">
    <div id="statusToast" class="toast" role="alert">
        <div class="toast-header bg-dark text-white">
            <strong class="me-auto">Satori</strong>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast"></button>
        </div>
        <div class="toast-body" id="toastMessage"></div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    const API_URL = '/api';
    const pageMode = '{{ page_mode|default("dashboard") }}';

    // Helper function to format balance values (removes trailing zeros)
    function formatBalance(value) {
        if (value === undefined || value === null) return '--';
        // Format to 8 decimals then parse to remove trailing zeros
        return parseFloat(parseFloat(value).toFixed(8)).toString();
    }

    // Get color for commission percentage (light green at 0% to red at 100%)
    function getCommissionColor(percentage) {
        // Clamp percentage between 0 and 100
        const p = Math.max(0, Math.min(100, percentage));

        // Light green (144, 238, 144) at 0% to red (220, 53, 69) at 100%
        const r = Math.round(144 + (220 - 144) * (p / 100));
        const g = Math.round(238 + (53 - 238) * (p / 100));
        const b = Math.round(144 + (69 - 144) * (p / 100));

        return `rgb(${r}, ${g}, ${b})`;
    }

    // State tracking for mutual exclusion
    let isStakingToPool = false;
    let isOpenPool = false;  // True if pool has commission > 0 (accepting pool stakers)
    let hasWorkers = false;  // True if user has workers (active pool)

    function showToast(message, isError = false) {
        const toast = document.getElementById('statusToast');
        const toastBody = document.getElementById('toastMessage');
        toastBody.textContent = message;
        toastBody.className = 'toast-body ' + (isError ? 'text-danger' : 'text-success');
        const bsToast = new bootstrap.Toast(toast);
        bsToast.show();
    }

    async function apiCall(endpoint, method = 'GET', data = null) {
        let isNetworkError = false;
        try {
            const options = {
                method: method,
                headers: {
                    'Content-Type': 'application/json'
                }
            };
            if (data) {
                options.body = JSON.stringify(data);
            }
            const response = await fetch(API_URL + endpoint, options);

            // If we got a response, server is reachable - update status to connected
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            if (indicator && text) {
                indicator.className = 'status-indicator status-online';
                text.textContent = 'Connected';
            }

            // Check if response is JSON
            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
                const text = await response.text();
                throw new Error(`Server returned non-JSON response: ${text.substring(0, 100)}`);
            }

            const result = await response.json();

            // Check for HTTP errors (but server is still connected)
            if (!response.ok) {
                // Handle error properly - could be string or object
                let errorMsg = `HTTP ${response.status}`;
                if (result.detail) {
                    errorMsg = typeof result.detail === 'object' ? JSON.stringify(result.detail) : result.detail;
                } else if (result.error) {
                    errorMsg = typeof result.error === 'object' ? JSON.stringify(result.error) : result.error;
                }
                throw new Error(errorMsg);
            }

            return result;
        } catch (error) {
            console.error('API Error:', error);

            // Only show "Disconnected" for network errors (not HTTP errors like 404, 401)
            // Network errors: TypeError (failed to fetch), timeout, connection refused
            if (error instanceof TypeError || error.message.includes('fetch') || error.message.includes('network')) {
                isNetworkError = true;
                const indicator = document.getElementById('statusIndicator');
                const text = document.getElementById('statusText');
                if (indicator && text) {
                    indicator.className = 'status-indicator status-offline';
                    text.textContent = 'Disconnected';
                }
            }

            // Ensure error message is always a string
            const errorMsg = error.message || String(error);
            showToast('API Error: ' + errorMsg, true);
            return null;
        }
    }

    // Update UI based on mutual exclusion rules
    function updateMutualExclusionUI() {
        const poolStakingReasonCommission = 'You cannot stake to a pool while you have commission set (open pool)';
        const poolStakingReasonWorkers = 'You cannot stake to a pool while you have workers (active pool)';

        // Pool Staking elements
        const poolAddressInput = document.getElementById('poolAddress');
        const poolAddressWrapper = document.getElementById('poolAddressWrapper');
        const addStakeBtn = document.getElementById('addStakeBtn');
        const addStakeBtnWrapper = document.getElementById('addStakeBtnWrapper');
        const removeStakeBtn = document.getElementById('removeStakeBtn');
        const removeStakeBtnWrapper = document.getElementById('removeStakeBtnWrapper');

        // Pool Management elements
        const poolCommission = document.getElementById('poolCommission');
        const poolCommissionWrapper = document.getElementById('poolCommissionWrapper');
        const newWorkerInput = document.getElementById('newWorkerAddress');
        const addWorkerBtn = document.getElementById('addWorkerBtn');
        const addWorkerWrapper = document.getElementById('addWorkerWrapper');

        // Pool Staking inputs are always enabled
        // (Commented out: previously disabled when user was a pool operator)
        /*
        if (isOpenPool || hasWorkers) {
            const reason = isOpenPool ? poolStakingReasonCommission : poolStakingReasonWorkers;
            poolAddressInput.disabled = true;
            poolAddressWrapper.setAttribute('title', reason);
            addStakeBtn.disabled = true;
            addStakeBtnWrapper.setAttribute('title', reason);
            removeStakeBtn.disabled = true;
            removeStakeBtnWrapper.setAttribute('title', reason);
        } else {
        */
            poolAddressInput.disabled = false;
            poolAddressWrapper.setAttribute('title', '');
            addStakeBtn.disabled = false;
            addStakeBtnWrapper.setAttribute('title', '');
            // Remove button only enabled if actually staking to a pool
            if (isStakingToPool) {
                removeStakeBtn.disabled = false;
                removeStakeBtnWrapper.setAttribute('title', '');
            } else {
                removeStakeBtn.disabled = true;
                removeStakeBtnWrapper.setAttribute('title', 'You are not currently staking to a pool');
            }
        // }

        // If staking to pool, dim Pool Management card and show notice
        const poolManagementBody = document.getElementById('poolManagementBody');
        const poolStakingNotice = document.getElementById('poolStakingNotice');

        if (isStakingToPool) {
            poolManagementBody.classList.add('dimmed');
            poolStakingNotice.style.display = 'block';
        } else {
            poolManagementBody.classList.remove('dimmed');
            poolStakingNotice.style.display = 'none';
        }

        // Update card collapse states based on usage
        updateCardCollapseStates();
    }

    function updateCardCollapseStates() {
        const poolStakingCollapse = document.getElementById('poolStakingCollapse');
        const poolManagementCollapse = document.getElementById('poolManagementCollapse');

        if (poolStakingCollapse) {
            // Show Pool Staking card if user is staking to a pool
            if (isStakingToPool) {
                poolStakingCollapse.classList.add('show');
            } else {
                poolStakingCollapse.classList.remove('show');
            }
        }

        if (poolManagementCollapse) {
            // Show Pool Management card if user is an open pool or has workers
            if (isOpenPool || hasWorkers) {
                poolManagementCollapse.classList.add('show');
            } else {
                poolManagementCollapse.classList.remove('show');
            }
        }
    }

    function setBalanceLoading(elementId, isLoading) {
        const element = document.getElementById(elementId);
        if (isLoading) {
            element.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span>';
        }
    }

    async function loadBalance() {
        // Load stake from Satori API server (only source for stake info)
        try {
            const result = await apiCall('/balance/get');
            if (result && result.stake !== undefined) {
                document.getElementById('stakeBalance').textContent = result.stake;
            } else {
                document.getElementById('stakeBalance').textContent = '--';
            }
        } catch (error) {
            console.error('Failed to load stake balance:', error);
            document.getElementById('stakeBalance').textContent = '--';
        }
    }

    async function refreshBalance() {
        // Get real-time balance from electrumx blockchain (wallet + vault)
        // Fetches SATORI token and EVR balance
        setBalanceLoading('tokenBalance', true);
        setBalanceLoading('evrBalance', true);

        try {
            const result = await apiCall('/wallet/balance/direct');
            if (result && !result.error) {
                document.getElementById('tokenBalance').textContent = result.total !== undefined ? formatBalance(result.total) : '--';
                document.getElementById('evrBalance').textContent = result.total_evr !== undefined ? formatBalance(result.total_evr) : '--';

                // Show/hide no-EVR warning
                const noEvrWarning = document.getElementById('noEvrWarning');
                if (noEvrWarning) {
                    noEvrWarning.style.display = (result.total_evr !== undefined && parseFloat(result.total_evr) <= 0) ? 'block' : 'none';
                }

                // Update balance labels in send section
                if (result.vault_balance !== undefined) {
                    document.getElementById('vaultBalanceLabel').textContent = '(' + formatBalance(result.vault_balance) + ')';
                }
                if (result.wallet_balance !== undefined) {
                    document.getElementById('walletBalanceLabel').textContent = '(' + formatBalance(result.wallet_balance) + ')';
                }
            } else {
                // If there's an error, show dashes
                document.getElementById('tokenBalance').textContent = '--';
                document.getElementById('evrBalance').textContent = '--';
                document.getElementById('vaultBalanceLabel').textContent = '(--)';
                document.getElementById('walletBalanceLabel').textContent = '(--)';
                if (result && result.error) {
                    console.error('ElectrumX balance fetch error:', result.error);
                }
            }
        } catch (error) {
            console.error('Failed to fetch balance from ElectrumX:', error);
            document.getElementById('tokenBalance').textContent = '--';
            document.getElementById('evrBalance').textContent = '--';
            document.getElementById('vaultBalanceLabel').textContent = '(--)';
            document.getElementById('walletBalanceLabel').textContent = '(--)';
        }
    }

    async function loadAllBalances() {
        // Load both stake (from API) and live balances (from ElectrumX)
        await Promise.all([
            loadBalance(),      // Stake from Satori API
            refreshBalance()    // SATORI and EVR from ElectrumX
        ]);
    }

    async function loadRewardAddress() {
        const result = await apiCall('/peer/reward-address');
        if (result && result.reward_address) {
            document.getElementById('currentRewardAddress').value = result.reward_address;
        }
    }

    async function setRewardAddress() {
        const address = document.getElementById('newRewardAddress').value.trim();
        if (!address) {
            showToast('Please enter an address', true);
            return;
        }
        if (!isValidAddress(address)) {
            showToast('Invalid address: must start with E and be 34 characters', true);
            return;
        }

        // Check if same as current address
        const currentAddress = document.getElementById('currentRewardAddress').value;
        if (address === currentAddress) {
            showToast('This reward address is already set', true);
            document.getElementById('newRewardAddress').value = '';
            return;
        }

        // Backend handles server sync
        const result = await apiCall('/peer/reward-address', 'POST', { reward_address: address });
        if (result && result.success) {
            showToast('Reward address updated');
            loadRewardAddress();
            document.getElementById('newRewardAddress').value = '';
        }
    }

    async function loadStakingStatus() {
        // Get wallet address first
        const walletData = await apiCall('/wallet/address');
        if (!walletData || !walletData.wallet_address) {
            const statusEl = document.getElementById('stakingStatus');
            statusEl.className = 'alert alert-warning';
            statusEl.textContent = 'Unable to load staking status';
            return;
        }

        // Query lender status with wallet address
        const result = await apiCall(`/lender/status?wallet_address=${encodeURIComponent(walletData.wallet_address)}`);
        const statusEl = document.getElementById('stakingStatus');
        if (result && result.pool_address) {
            isStakingToPool = true;
            statusEl.className = 'alert alert-success';
            statusEl.textContent = 'Staking with pool: ' + result.pool_address;
            // Update the pool address input field
            document.getElementById('poolAddress').value = result.pool_address;
        } else {
            isStakingToPool = false;
            statusEl.className = 'alert alert-secondary';
            statusEl.textContent = 'Not staking with a pool';
            // Clear the pool address input field
            document.getElementById('poolAddress').value = '';
        }
        updateMutualExclusionUI();
    }

    async function addStakeToPool() {
        const pool = document.getElementById('poolAddress').value.trim();
        if (!pool) {
            showToast('Please enter a pool address', true);
            return;
        }
        if (!isValidAddress(pool)) {
            showToast('Invalid address: must start with E and be 34 characters', true);
            return;
        }
        const result = await apiCall('/lender/lend', 'POST', { pool_address: pool });
        if (result) {
            showToast('Stake added to pool');
            loadStakingStatus();
        }
    }

    async function removeStakeFromPool() {
        const result = await apiCall('/lender/lend', 'DELETE');
        if (result) {
            showToast('Stake removed from pool');
            loadStakingStatus();
        }
    }

    async function loadAvailablePools() {
        const listEl = document.getElementById('availablePoolsList');
        listEl.innerHTML = '<div class="text-muted small p-2">Loading pools...</div>';

        const result = await apiCall('/pool/open', 'GET');
        if (result && result.pools && result.pools.length > 0) {
            listEl.innerHTML = '';
            // Sort pools by increasing commission fee percentage
            result.pools.sort((a, b) => a.commission - b.commission);
            result.pools.forEach(pool => {
                const item = document.createElement('a');
                item.href = '#';
                item.className = 'list-group-item list-group-item-action';
                item.onclick = (e) => {
                    e.preventDefault();
                    document.getElementById('poolAddress').value = pool.address;
                };
                const commissionColor = getCommissionColor(pool.commission);
                item.innerHTML = `
                    <div class="d-flex w-100 justify-content-between align-items-center">
                        <div>
                            <small class="text-muted">Address:</small><br>
                            <code class="small">${pool.address}</code>
                        </div>
                        <div class="text-end">
                            ${pool.alias ? `<span class="badge bg-primary">${pool.alias}</span><br>` : ''}
                            <small class="fw-bold" style="color: ${commissionColor}">${pool.commission}% Fee</small>
                        </div>
                    </div>
                `;
                listEl.appendChild(item);
            });
        } else {
            listEl.innerHTML = '<div class="text-muted small p-2">No open pools available</div>';
        }
    }

    async function setPoolCommission() {
        const commissionInput = document.getElementById('poolCommission');
        let commission = commissionInput.value ? parseInt(commissionInput.value) : null;

        // Validate
        if (commission !== null && (commission < 0 || commission > 100)) {
            showToast('Commission must be between 0 and 100', true);
            return;
        }

        // Send commission directly to server (no conversion)
        // commission = % pool keeps as fee
        const result = await apiCall('/pool/toggle-open', 'POST', { commission: commission });
        if (result) {
            const msg = commission === null || commission === 0 ? 'Pool closed' : `Pool open with ${commission}% commission fee`;
            showToast(msg);
            await loadPoolCommission();
            await loadAvailablePools();  // Refresh pool list to show updated commission
            updateMutualExclusionUI();
        }
    }

    async function loadPoolCommission() {
        const result = await apiCall('/pool/commission', 'GET');
        if (result) {
            const commissionInput = document.getElementById('poolCommission');
            // Display commission directly (no conversion)
            commissionInput.value = result.commission !== null ? result.commission : '';
            isOpenPool = result.commission !== null && result.commission > 0;
            updateMutualExclusionUI();  // Update UI after setting isOpenPool
        }
    }

    async function loadWorkers() {
        const workerListEl = document.getElementById('workerList');
        const result = await apiCall('/pool/workers');

        if (result && result.workers && result.workers.length > 0) {
            hasWorkers = true;
            workerListEl.innerHTML = '';
            result.workers.forEach(worker => {
                const workerItem = document.createElement('div');
                workerItem.className = 'd-flex justify-content-between align-items-center mb-2 p-2 border rounded';
                workerItem.innerHTML = `
                    <div>
                        <small class="text-muted">Address:</small><br>
                        <code class="small">${worker.address}</code>
                        ${worker.alias ? `<br><span class="badge bg-secondary">${worker.alias}</span>` : ''}
                    </div>
                    <button class="btn btn-sm btn-danger" onclick="removeWorker('${worker.address}')">
                        <i class="material-icons align-middle" style="font-size: 16px;">delete</i>
                    </button>
                `;
                workerListEl.appendChild(workerItem);
            });
        } else {
            hasWorkers = false;
            workerListEl.innerHTML = '<p class="text-muted">No workers</p>';
        }

        updateMutualExclusionUI();
    }

    async function loadLenders() {
        const lenderListEl = document.getElementById('lenderList');
        const result = await apiCall('/pool/lenders');

        if (result && result.lenders && result.lenders.length > 0) {
            lenderListEl.innerHTML = '';
            result.lenders.forEach(lender => {
                const lenderItem = document.createElement('div');
                lenderItem.className = 'd-flex justify-content-between align-items-center mb-2 p-2 border rounded';
                lenderItem.innerHTML = `
                    <div>
                        <small class="text-muted">Address:</small><br>
                        <code class="small">${lender.address}</code>
                        ${lender.alias ? `<br><span class="badge bg-secondary">${lender.alias}</span>` : ''}
                    </div>
                `;
                lenderListEl.appendChild(lenderItem);
            });
        } else {
            lenderListEl.innerHTML = '<p class="text-muted">No pool stakers</p>';
        }
    }

    // Get central-lite API URL
    function getCentralApiUrl() {
        // Always use the production Satori network server for audit files
        return 'https://network.satorinet.io';
    }

    // Helper function to download JSON data as a file
    function downloadJSON(data, filename) {
        const blob = new Blob([JSON.stringify(data, null, 2)], {
            type: 'application/json'
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // Download workers audit
    async function downloadWorkersAudit() {
        try {
            const centralApiUrl = getCentralApiUrl();
            const response = await fetch(`${centralApiUrl}/api/v1/audit/workers/latest`);

            if (!response.ok) {
                if (response.status === 404) {
                    showToast('No workers audit available yet', 'warning');
                    return;
                }
                throw new Error(`HTTP ${response.status}`);
            }

            const csvText = await response.text();

            // Generate filename with timestamp
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `workers_audit_${timestamp}.csv`;

            // Download CSV file
            const blob = new Blob([csvText], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);

            showToast('Workers audit downloaded');
        } catch (error) {
            console.error('Error downloading workers audit:', error);
            showToast('Failed to download workers audit', 'error');
        }
    }

    // Download pool stakers audit
    async function downloadLendersAudit() {
        try {
            const centralApiUrl = getCentralApiUrl();
            const response = await fetch(`${centralApiUrl}/api/v1/audit/stakers/latest`);

            if (!response.ok) {
                if (response.status === 404) {
                    showToast('No pool stakers audit available yet', 'warning');
                    return;
                }
                throw new Error(`HTTP ${response.status}`);
            }

            const csvText = await response.text();

            // Generate filename with timestamp
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `stakers_audit_${timestamp}.csv`;

            // Download CSV file
            const blob = new Blob([csvText], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);

            showToast('Pool stakers audit downloaded');
        } catch (error) {
            console.error('Error downloading pool stakers audit:', error);
            showToast('Failed to download pool stakers audit', 'error');
        }
    }

    function isValidAddress(address) {
        return address && address.length === 34 && address.startsWith('E');
    }

    async function addWorker() {
        const address = document.getElementById('newWorkerAddress').value.trim();
        if (!address) {
            showToast('Please enter a worker address', true);
            return;
        }
        if (!isValidAddress(address)) {
            showToast('Invalid address: must start with E and be 34 characters', true);
            return;
        }
        const result = await apiCall('/pool/worker', 'POST', { worker_address: address });
        if (result) {
            showToast('Worker added');
            document.getElementById('newWorkerAddress').value = '';
            loadWorkers();
        }
    }

    async function removeWorker(address) {
        const result = await apiCall(`/pool/worker/${address}`, 'DELETE');
        if (result) {
            showToast('Worker removed');
            loadWorkers();
        }
    }

    async function checkHealth() {
        try {
            const response = await fetch('/health');
            const data = await response.json();
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            if (data.api === 'connected') {
                indicator.className = 'status-indicator status-online';
                text.textContent = 'Connected';
            } else {
                indicator.className = 'status-indicator status-offline';
                text.textContent = 'Disconnected';
            }
        } catch (error) {
            document.getElementById('statusIndicator').className = 'status-indicator status-offline';
            document.getElementById('statusText').textContent = 'Disconnected';
        }
    }

    async function loadWalletAddresses() {
        const result = await apiCall('/wallet/address');
        if (result) {
            // Main wallet uses vault address
            if (result.vault_address) {
                document.getElementById('walletAddress').value = result.vault_address;
                loadQrCode(result.vault_address);
            } else {
                document.getElementById('walletAddress').value = 'Not available';
                document.getElementById('walletQrCode').innerHTML = '<p class="text-muted mb-0">No address</p>';
            }
            // Identity wallet (for backup)
            if (result.wallet_address) {
                document.getElementById('identityAddress').value = result.wallet_address;
            } else {
                document.getElementById('identityAddress').value = 'Not available';
            }
        }
    }

    // Identity Wallet functions
    let identityWalletVisible = false;
    let identityPrivateKeyLoaded = false;
    let identityPrivateKeyVisible = false;

    function toggleIdentityWallet() {
        const section = document.getElementById('identityWalletSection');
        identityWalletVisible = !identityWalletVisible;
        section.style.display = identityWalletVisible ? 'block' : 'none';
    }

    async function toggleIdentityPrivateKey() {
        const input = document.getElementById('identityPrivateKey');
        const icon = document.getElementById('identityKeyIcon');

        if (!identityPrivateKeyLoaded) {
            // Load the identity private key from API
            const result = await apiCall('/wallet/identity-private-key');
            if (result && result.private_key) {
                input.value = result.private_key;
                identityPrivateKeyLoaded = true;
            } else {
                input.value = 'Unable to load';
            }
        }

        identityPrivateKeyVisible = !identityPrivateKeyVisible;
        input.type = identityPrivateKeyVisible ? 'text' : 'password';
        icon.textContent = identityPrivateKeyVisible ? 'visibility_off' : 'visibility';
    }

    function copyIdentityPrivateKey() {
        const input = document.getElementById('identityPrivateKey');
        if (input.value && input.value !== 'Click to reveal...' && input.value !== 'Unable to load') {
            // Check if Clipboard API is available (requires HTTPS or localhost)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(input.value).then(() => {
                    showToast('Identity private key copied to clipboard');
                }).catch(() => {
                    // Fallback for older browsers or non-HTTPS
                    input.select();
                    try {
                        document.execCommand('copy');
                        showToast('Identity private key copied to clipboard');
                    } catch (err) {
                        showToast('Failed to copy', true);
                    }
                });
            } else {
                // Fallback for older browsers or non-HTTPS
                input.select();
                try {
                    document.execCommand('copy');
                    showToast('Identity private key copied to clipboard');
                } catch (err) {
                    showToast('Failed to copy', true);
                }
            }
        } else {
            showToast('Please reveal the private key first', true);
        }
    }

    function copyToClipboard(elementId) {
        const input = document.getElementById(elementId);
        const value = input.value;
        if (value && value !== 'Loading...' && value !== 'Not available') {
            // Check if Clipboard API is available (requires HTTPS or localhost)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(value).then(() => {
                    showToast('Address copied to clipboard');
                }).catch(() => {
                    // Fallback for older browsers or non-HTTPS
                    try {
                        input.select();
                        document.execCommand('copy');
                        showToast('Address copied to clipboard');
                    } catch (err) {
                        showToast('Failed to copy address', true);
                    }
                });
            } else {
                // Fallback for older browsers or non-HTTPS
                try {
                    input.select();
                    document.execCommand('copy');
                    showToast('Address copied to clipboard');
                } catch (err) {
                    showToast('Failed to copy address', true);
                }
            }
        } else {
            showToast('No address to copy', true);
        }
    }

    // Relay Registration
    async function registerRelay() {
        const relayUrl = document.getElementById('relayUrl').value.trim();
        const statusEl = document.getElementById('relayStatus');

        if (!relayUrl) {
            statusEl.style.display = 'inline';
            statusEl.className = 'ms-3 text-danger';
            statusEl.textContent = 'Please enter a relay URL';
            return;
        }

        if (!relayUrl.startsWith('wss://') && !relayUrl.startsWith('ws://')) {
            statusEl.style.display = 'inline';
            statusEl.className = 'ms-3 text-danger';
            statusEl.textContent = 'URL must start with wss:// or ws://';
            return;
        }

        statusEl.style.display = 'inline';
        statusEl.className = 'ms-3 text-info';
        statusEl.textContent = 'Verifying relay...';

        try {
            const resp = await fetch('/api/relay', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({relay_url: relayUrl})
            });
            const data = await resp.json();
            if (resp.ok && (data.success || data.relay_url)) {
                statusEl.className = 'ms-3 text-success';
                statusEl.textContent = 'Relay verified and registered';
            } else {
                statusEl.className = 'ms-3 text-danger';
                statusEl.textContent = data.error || data.detail || 'Verification failed';
            }
        } catch (err) {
            statusEl.className = 'ms-3 text-danger';
            statusEl.textContent = 'Connection error: ' + err.message;
        }
    }

    // Network Datastreams & Subscriptions
    function formatCadence(s) {
        if (!s) return '-';
        return s >= 3600 ? (s / 3600) + 'h' : s + 's';
    }

    function btnLoading(btn) {
        btn.disabled = true;
        btn._origText = btn.textContent;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';
    }
    function btnDone(btn) {
        if (btn) { btn.disabled = false; btn.textContent = btn._origText || ''; }
    }

    async function networkSubscribe(stream, btn) {
        if (btn) btnLoading(btn);
        await fetch('/api/network/subscribe', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(stream)
        });
        loadNetworkStreams();
        loadNetworkSubscriptions();
    }

    async function networkResubscribe(streamName, pubkey, relayUrl, btn) {
        if (btn) btnLoading(btn);
        await fetch('/api/network/subscribe', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({stream_name: streamName, nostr_pubkey: pubkey, relay_url: relayUrl})
        });
        loadNetworkSubscriptions();
    }

    async function networkUnsubscribe(streamName, pubkey, btn) {
        if (btn) btnLoading(btn);
        await fetch('/api/network/unsubscribe', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({stream_name: streamName, nostr_pubkey: pubkey})
        });
        loadNetworkStreams();
        loadNetworkSubscriptions();
    }

    async function networkPredict(streamName, pubkey, btn) {
        if (btn) btnLoading(btn);
        await fetch('/api/network/predict', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({stream_name: streamName, nostr_pubkey: pubkey})
        });
        loadNetworkSubscriptions();
        loadPublications();
    }

    async function networkStopPredict(streamName, btn) {
        if (btn) btnLoading(btn);
        await fetch('/api/network/stop-predict', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({stream_name: streamName})
        });
        loadNetworkSubscriptions();
        loadPublications();
    }

    // ── Observations drawer ──────────────────────────────────
    let obsDrawerData = {observations: [], predictions: []};
    let obsDrawerTab = 'observations';
    let obsChart = null;

    function closeObsDrawer() {
        document.getElementById('obsDrawer').style.display = 'none';
        if (obsChart) { obsChart.destroy(); obsChart = null; }
    }

    function tryParseFloat(val) {
        if (val == null) return null;
        try {
            const parsed = JSON.parse(val);
            if (typeof parsed === 'number') return parsed;
        } catch(e) {}
        const n = parseFloat(val);
        return isNaN(n) ? null : n;
    }

    function renderObsChart() {
        const container = document.getElementById('obsChartContainer');
        const ctx = document.getElementById('obsChart');
        if (obsChart) { obsChart.destroy(); obsChart = null; }
        // Build observation points (oldest first)
        const obsPoints = obsDrawerData.observations
            .slice().reverse()
            .map(o => ({x: (o.observed_at || o.received_at) * 1000, y: tryParseFloat(o.value)}))
            .filter(p => p.y !== null);
        // Predictions are shifted forward: prediction made at T1 is for
        // the next observation, so align with the next obs timestamp.
        // The last prediction has no next obs yet — extrapolate using cadence.
        const obsTimes = obsPoints.map(p => p.x);
        const rawPreds = obsDrawerData.predictions
            .slice().reverse()
            .map(p => ({x: (p.observed_at || p.created_at) * 1000, y: tryParseFloat(p.value)}))
            .filter(p => p.y !== null);
        // Estimate cadence from observation spacing
        let cadenceMs = 0;
        if (obsTimes.length >= 2) {
            const diffs = [];
            for (let i = 1; i < obsTimes.length; i++) diffs.push(obsTimes[i] - obsTimes[i-1]);
            cadenceMs = diffs.reduce((a, b) => a + b, 0) / diffs.length;
        }
        const predPoints = rawPreds.map((p, i) => {
            const obsIdx = obsTimes.findIndex(t => t >= p.x);
            const nextIdx = obsIdx >= 0 ? obsIdx + 1 : -1;
            if (nextIdx >= 0 && nextIdx < obsTimes.length) {
                return {x: obsTimes[nextIdx], y: p.y};
            }
            // Last prediction: extrapolate one cadence into the future
            const lastTime = obsTimes.length > 0
                ? obsTimes[obsTimes.length - 1] : p.x;
            return {x: lastTime + (cadenceMs || 60000), y: p.y};
        });
        if (obsPoints.length === 0 && predPoints.length === 0) {
            container.style.display = 'none';
            return;
        }
        container.style.display = 'block';
        const datasets = [];
        if (obsPoints.length > 0) {
            datasets.push({
                label: 'Observations',
                data: obsPoints,
                borderColor: 'rgba(54, 162, 235, 1)',
                backgroundColor: 'rgba(54, 162, 235, 0.1)',
                borderWidth: 2, pointRadius: 3, tension: 0.1, fill: false,
            });
        }
        if (predPoints.length > 0) {
            datasets.push({
                label: 'Predictions',
                data: predPoints,
                borderColor: 'rgba(255, 159, 64, 1)',
                backgroundColor: 'rgba(255, 159, 64, 0.1)',
                borderWidth: 2, pointRadius: 3, tension: 0.1,
                borderDash: [5, 3], fill: false,
            });
        }
        obsChart = new Chart(ctx, {
            type: 'line',
            data: {datasets},
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {mode: 'index', intersect: false},
                scales: {
                    x: {type: 'time', time: {tooltipFormat: 'MMM d, HH:mm'}},
                    y: {beginAtZero: false},
                },
                plugins: {legend: {position: 'top'}},
            },
        });
    }

    function switchObsTab(tab, link) {
        obsDrawerTab = tab;
        document.querySelectorAll('#obsDrawerTabs .nav-link').forEach(l => l.classList.remove('active'));
        link.classList.add('active');
        renderObsDrawer();
    }

    function renderObsDrawer() {
        const head = document.getElementById('obsDrawerHead');
        const body = document.getElementById('obsDrawerBody');
        body.innerHTML = '';
        if (obsDrawerTab === 'observations') {
            head.innerHTML = '<tr><th>Seq</th><th>Observed At</th><th>Received At</th><th>Value</th></tr>';
            obsDrawerData.observations.forEach(o => {
                const row = document.createElement('tr');
                let val = o.value || '';
                try { val = JSON.stringify(JSON.parse(val)); } catch(e) {}
                if (val.length > 80) val = val.substring(0, 80) + '...';
                row.innerHTML =
                    '<td>' + (o.seq_num != null ? o.seq_num : '-') + '</td>' +
                    '<td>' + (o.observed_at ? formatTimeAgo(o.observed_at) : '-') + '</td>' +
                    '<td>' + formatTimeAgo(o.received_at) + '</td>' +
                    '<td><code>' + val + '</code></td>';
                body.appendChild(row);
            });
        } else {
            head.innerHTML = '<tr><th>Obs Seq</th><th>Observed At</th><th>Created At</th><th>Value</th><th>Published</th></tr>';
            obsDrawerData.predictions.forEach(p => {
                const row = document.createElement('tr');
                let val = p.value || '';
                try { val = JSON.stringify(JSON.parse(val)); } catch(e) {}
                if (val.length > 80) val = val.substring(0, 80) + '...';
                row.innerHTML =
                    '<td>' + (p.observation_seq != null ? p.observation_seq : '-') + '</td>' +
                    '<td>' + (p.observed_at ? formatTimeAgo(p.observed_at) : '-') + '</td>' +
                    '<td>' + formatTimeAgo(p.created_at) + '</td>' +
                    '<td><code>' + val + '</code></td>' +
                    '<td>' + (p.published ? '<span class="badge bg-success">Yes</span>' : '<span class="badge bg-secondary">No</span>') + '</td>';
                body.appendChild(row);
            });
        }
        if (body.children.length === 0) {
            body.innerHTML = '<tr><td colspan="5" class="text-center text-muted">No data yet.</td></tr>';
        }
    }

    async function openObsDrawer(streamName, providerPubkey) {
        const drawer = document.getElementById('obsDrawer');
        const title = document.getElementById('obsDrawerTitle');
        const body = document.getElementById('obsDrawerBody');
        title.textContent = streamName;
        body.innerHTML = '<tr><td colspan="4" class="text-center"><span class="spinner-border spinner-border-sm"></span> Loading...</td></tr>';
        drawer.style.display = 'block';
        obsDrawerTab = 'observations';
        document.querySelectorAll('#obsDrawerTabs .nav-link').forEach((l, i) =>
            i === 0 ? l.classList.add('active') : l.classList.remove('active'));
        try {
            const resp = await fetch('/api/network/observations?stream_name=' +
                encodeURIComponent(streamName) + '&provider_pubkey=' +
                encodeURIComponent(providerPubkey));
            obsDrawerData = await resp.json();
            renderObsChart();
            renderObsDrawer();
        } catch(e) {
            body.innerHTML = '<tr><td colspan="4" class="text-center text-danger">Failed to load</td></tr>';
        }
    }

    let showInactiveSubs = false;

    function toggleInactiveSubs() {
        showInactiveSubs = !showInactiveSubs;
        const btn = document.getElementById('subsToggleInactive');
        btn.textContent = showInactiveSubs ? 'Hide Inactive' : 'Show Inactive';
        loadNetworkSubscriptions();
    }

    async function loadNetworkSubscriptions() {
        try {
            const url = showInactiveSubs
                ? '/api/network/subscriptions?all=1'
                : '/api/network/subscriptions';
            const resp = await fetch(url);
            const data = await resp.json();
            const empty = document.getElementById('subsEmpty');
            const table = document.getElementById('subsTable');
            const list = document.getElementById('subsList');

            if (!data.subscriptions || data.subscriptions.length === 0) {
                empty.style.display = 'block';
                table.style.display = 'none';
                return;
            }
            empty.style.display = 'none';
            table.style.display = 'block';
            list.innerHTML = '';
            data.subscriptions.forEach(s => {
                const row = document.createElement('tr');
                const inactive = s.active === 0;
                const stale = s.stale_since != null;
                if (inactive) row.classList.add('text-muted');
                else if (stale) row.classList.add('text-muted');
                const statusBadge = inactive
                    ? '<span class="badge bg-secondary">Inactive</span>'
                    : stale
                        ? '<span class="badge bg-warning text-dark">Stale</span>'
                        : '<span class="badge bg-success">Active</span>';
                const actionBtn = inactive
                    ? '<button class="btn btn-sm btn-outline-success" onclick="networkResubscribe(\'' +
                      s.stream_name.replace(/'/g, "\\'") + "', '" +
                      s.provider_pubkey.replace(/'/g, "\\'") + "', '" +
                      (s.relay_url || '').replace(/'/g, "\\'") + '\', this)">Resubscribe</button>'
                    : '<button class="btn btn-sm btn-outline-danger" onclick="networkUnsubscribe(\'' +
                      s.stream_name.replace(/'/g, "\\'") + "', '" +
                      s.provider_pubkey.replace(/'/g, "\\'") + '\', this)">Unsubscribe</button>';
                const predictBtn = inactive ? '' : (s.predicting
                    ? '<button class="btn btn-sm btn-outline-warning ms-1" onclick="networkStopPredict(\'' +
                      s.stream_name.replace(/'/g, "\\'") + '\', this)">Stop Predicting</button>'
                    : '<button class="btn btn-sm btn-outline-info ms-1" onclick="networkPredict(\'' +
                      s.stream_name.replace(/'/g, "\\'") + "', '" +
                      s.provider_pubkey.replace(/'/g, "\\'") + '\', this)">Predict</button>');
                const nameLink = '<a href="#" style="text-decoration:none" onclick="openObsDrawer(\'' +
                    s.stream_name.replace(/'/g, "\\'") + "', '" +
                    s.provider_pubkey.replace(/'/g, "\\'") + '\'); return false;"><strong>' +
                    (s.name || s.stream_name) + '</strong></a>';
                row.innerHTML =
                    '<td>' + nameLink + '</td>' +
                    '<td><small class="text-muted">' + (s.relay_url || '-') + '</small></td>' +
                    '<td>' + formatCadence(s.cadence_seconds) + '</td>' +
                    '<td>' + statusBadge + '</td>' +
                    '<td>' + actionBtn + predictBtn + '</td>';
                list.appendChild(row);
            });
        } catch (err) { /* ignore */ }
    }

    // ── Data Source Form ──────────────────────────────────────
    function downloadCsvTemplate() {
        const header = 'stream_name,name,description,url,method,headers,cadence_minutes,parser_type,parser_config';
        const example = 'btc-price,Bitcoin Price,BTC/USD spot price,https://api.example.com/price,GET,,60,json_path,data.price';
        const csv = header + '\n' + example + '\n';
        const blob = new Blob([csv], {type: 'text/csv'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'data_sources_template.csv';
        a.click();
    }

    async function uploadCsv(input) {
        const file = input.files[0];
        if (!file) return;
        const text = await file.text();
        input.value = '';
        const lines = text.trim().split('\n');
        if (lines.length < 2) { alert('CSV must have a header and at least one row'); return; }
        const headerRow = lines[0].split(',').map(h => h.trim().toLowerCase());
        if (!headerRow.includes('stream_name')) { alert('Missing required column: stream_name'); return; }
        let created = 0, errors = [];
        for (let i = 1; i < lines.length; i++) {
            if (!lines[i].trim()) continue;
            // Parse CSV respecting quoted fields
            const vals = lines[i].match(/(".*?"|[^,]*)/g) || [];
            const row = {};
            headerRow.forEach((h, idx) => {
                let v = (vals[idx] || '').trim();
                if (v.startsWith('"') && v.endsWith('"')) v = v.slice(1, -1);
                row[h] = v;
            });
            if (!row.stream_name) {
                errors.push('Row ' + (i+1) + ': missing stream_name');
                continue;
            }
            const cadenceMin = parseInt(row.cadence_minutes) || 0;
            const hasUrl = !!row.url;
            if (hasUrl && cadenceMin && cadenceMin < 15) {
                errors.push('Row ' + (i+1) + ': cadence must be at least 15 minutes');
                continue;
            }
            if (hasUrl && !row.parser_config) {
                errors.push('Row ' + (i+1) + ': parser_config required when URL is set');
                continue;
            }
            try {
                const resp = await fetch('/api/network/data-source', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        stream_name: row.stream_name,
                        name: row.name || '',
                        description: row.description || '',
                        url: row.url || '',
                        method: row.method || 'GET',
                        headers: row.headers || null,
                        cadence_seconds: cadenceMin ? cadenceMin * 60 : 0,
                        parser_type: hasUrl ? (row.parser_type || 'json_path') : '',
                        parser_config: hasUrl ? (row.parser_config || '') : '',
                    })
                });
                const data = await resp.json();
                if (data.error) errors.push('Row ' + (i+1) + ': ' + data.error);
                else created++;
            } catch(e) {
                errors.push('Row ' + (i+1) + ': ' + e.message);
            }
        }
        let msg = created + ' data source(s) created.';
        if (errors.length) msg += '\n\nErrors:\n' + errors.join('\n');
        alert(msg);
        loadPublications();
    }

    function toggleDataSourceForm(forceShow) {
        const form = document.getElementById('dataSourceForm');
        if (forceShow === true) {
            form.style.display = 'block';
        } else if (forceShow === false) {
            form.style.display = 'none';
            resetDataSourceForm();
        } else {
            form.style.display = form.style.display === 'none' ? 'block' : 'none';
            if (form.style.display === 'none') resetDataSourceForm();
        }
        document.getElementById('dsError').textContent = '';
    }

    function resetDataSourceForm() {
        document.getElementById('dsFormTitle').textContent = 'New Data Source';
        document.getElementById('dsStreamName').readOnly = false;
        ['dsStreamName','dsName','dsDescription','dsUrl','dsHeaders','dsParserJsonPath','dsParserPython'].forEach(
            id => document.getElementById(id).value = '');
        document.getElementById('dsCadenceMin').value = '';
        document.getElementById('dsMethod').value = 'GET';
        document.getElementById('dsParserType').value = 'json_path';
        toggleParserInput();
        toggleFetchFields();
        document.getElementById('dsTestResults').style.display = 'none';
    }

    async function editDataSource(streamName) {
        try {
            const resp = await fetch('/api/network/data-source?stream_name=' + encodeURIComponent(streamName));
            const data = await resp.json();
            if (data.error || !data.data_source) return false;
            const ds = data.data_source;
            // Populate form
            document.getElementById('dsFormTitle').textContent = 'Edit Data Source';
            document.getElementById('dsStreamName').value = ds.stream_name;
            document.getElementById('dsStreamName').readOnly = true;
            document.getElementById('dsName').value = ds.name || '';
            document.getElementById('dsDescription').value = ds.description || '';
            document.getElementById('dsUrl').value = ds.url || '';
            document.getElementById('dsMethod').value = ds.method || 'GET';
            document.getElementById('dsHeaders').value = ds.headers || '';
            document.getElementById('dsCadenceMin').value = ds.cadence_seconds ? Math.round(ds.cadence_seconds / 60) : '';
            document.getElementById('dsParserType').value = ds.parser_type || 'json_path';
            toggleParserInput();
            if (ds.parser_type === 'python') {
                document.getElementById('dsParserPython').value = ds.parser_config || '';
            } else {
                document.getElementById('dsParserJsonPath').value = ds.parser_config || '';
            }
            toggleFetchFields();
            document.getElementById('dsTestResults').style.display = 'none';
            document.getElementById('dsError').textContent = '';
            // Show form and scroll to it
            toggleDataSourceForm(true);
            document.getElementById('dataSourceForm').scrollIntoView({behavior: 'smooth', block: 'start'});
            return true;
        } catch(e) {
            return false;
        }
    }

    function applyCadencePreset() {
        const preset = document.getElementById('dsCadencePreset').value;
        if (preset) document.getElementById('dsCadenceMin').value = preset;
        document.getElementById('dsCadencePreset').value = '';
    }

    function toggleParserInput() {
        const type = document.getElementById('dsParserType').value;
        document.getElementById('dsParserJsonPathGroup').style.display = type === 'json_path' ? '' : 'none';
        document.getElementById('dsParserPythonGroup').style.display = type === 'python' ? '' : 'none';
    }

    function toggleFetchFields() {
        const hasUrl = document.getElementById('dsUrl').value.trim() !== '';
        document.getElementById('dsMethodGroup').style.display = hasUrl ? '' : 'none';
        document.getElementById('dsCadenceGroup').style.display = hasUrl ? '' : 'none';
        document.getElementById('dsHeadersGroup').style.display = hasUrl ? '' : 'none';
        document.getElementById('dsParserRow').style.display = hasUrl ? '' : 'none';
        document.getElementById('dsExternalHint').style.display = hasUrl ? 'none' : '';
    }

    function renderJsonTree(obj, path, container) {
        if (obj === null || obj === undefined) {
            const span = document.createElement('span');
            span.className = 'text-muted';
            span.textContent = 'null';
            span.style.cursor = 'pointer';
            span.onmouseover = () => span.style.backgroundColor = '#e3f2fd';
            span.onmouseout = () => span.style.backgroundColor = '';
            span.onclick = (e) => { e.stopPropagation(); selectJsonPath(path, String(obj)); };
            container.appendChild(span);
            return;
        }
        if (typeof obj !== 'object') {
            const span = document.createElement('span');
            span.style.cursor = 'pointer';
            span.className = typeof obj === 'string' ? 'text-success' : 'text-primary';
            span.textContent = typeof obj === 'string' ? '"' + obj + '"' : String(obj);
            span.onmouseover = () => span.style.backgroundColor = '#e3f2fd';
            span.onmouseout = () => span.style.backgroundColor = '';
            span.onclick = (e) => { e.stopPropagation(); selectJsonPath(path, String(obj)); };
            container.appendChild(span);
            return;
        }
        const isArray = Array.isArray(obj);
        const entries = isArray ? obj.map((v, i) => [String(i), v]) : Object.entries(obj);
        const bracket = isArray ? ['[', ']'] : ['{', '}'];
        if (entries.length === 0) {
            container.appendChild(document.createTextNode(bracket[0] + bracket[1]));
            return;
        }
        const toggle = document.createElement('span');
        toggle.textContent = bracket[0];
        toggle.style.cursor = 'pointer';
        toggle.className = 'text-muted';
        const inner = document.createElement('div');
        inner.style.paddingLeft = '16px';
        const close = document.createElement('span');
        close.textContent = bracket[1];
        close.className = 'text-muted';
        toggle.onclick = (e) => {
            e.stopPropagation();
            if (inner.style.display === 'none') {
                inner.style.display = '';
                close.style.display = '';
                toggle.textContent = bracket[0];
            } else {
                inner.style.display = 'none';
                close.style.display = 'none';
                toggle.textContent = bracket[0] + ' ... ' + bracket[1] + ' (' + entries.length + ')';
            }
        };
        container.appendChild(toggle);
        entries.forEach(([key, val], idx) => {
            const line = document.createElement('div');
            const childPath = path ? path + '.' + key : key;
            const keySpan = document.createElement('span');
            keySpan.className = 'fw-bold';
            keySpan.textContent = isArray ? key + ': ' : '"' + key + '": ';
            line.appendChild(keySpan);
            renderJsonTree(val, childPath, line);
            if (idx < entries.length - 1) line.appendChild(document.createTextNode(','));
            inner.appendChild(line);
        });
        container.appendChild(inner);
        container.appendChild(close);
    }

    function selectJsonPath(path, value) {
        document.getElementById('dsParserType').value = 'json_path';
        toggleParserInput();
        document.getElementById('dsParserJsonPath').value = path;
        document.getElementById('dsTestValue').innerHTML =
            '<span class="text-success fw-bold">' + value + '</span>' +
            '<br><small class="text-muted">Path: ' + path + '</small>';
    }

    async function testDataSource(btn) {
        const err = document.getElementById('dsError');
        err.textContent = '';
        const url = document.getElementById('dsUrl').value.trim();
        if (!url) { err.textContent = 'URL required'; return; }
        const parserType = document.getElementById('dsParserType').value;
        const parserConfig = parserType === 'json_path'
            ? document.getElementById('dsParserJsonPath').value.trim()
            : document.getElementById('dsParserPython').value.trim();
        if (!parserConfig) { err.textContent = 'Parser config required'; return; }
        const headers = document.getElementById('dsHeaders').value.trim() || null;
        btnLoading(btn);
        try {
            const resp = await fetch('/api/network/data-source/test', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    url: url,
                    method: document.getElementById('dsMethod').value,
                    headers: headers,
                    parser_type: parserType,
                    parser_config: parserConfig,
                })
            });
            const data = await resp.json();
            const results = document.getElementById('dsTestResults');
            const treeEl = document.getElementById('dsTestTree');
            const valEl = document.getElementById('dsTestValue');
            results.style.display = 'block';
            treeEl.innerHTML = '';
            // Try to render as interactive JSON tree
            let raw = data.raw || '';
            try {
                const parsed = JSON.parse(raw);
                renderJsonTree(parsed, '', treeEl);
            } catch(e) {
                // Not JSON — show as plain text
                const pre = document.createElement('pre');
                pre.style.margin = '0';
                pre.style.whiteSpace = 'pre-wrap';
                pre.textContent = raw;
                treeEl.appendChild(pre);
            }
            if (data.error) {
                valEl.innerHTML = '<span class="text-danger">' + data.error + '</span>';
            } else {
                valEl.innerHTML = '<span class="text-success fw-bold">' + data.value + '</span>';
            }
        } catch(e) {
            document.getElementById('dsError').textContent = 'Test failed: ' + e.message;
        }
        btnDone(btn);
    }

    async function saveDataSource(btn) {
        const err = document.getElementById('dsError');
        err.textContent = '';
        const streamName = document.getElementById('dsStreamName').value.trim();
        const url = document.getElementById('dsUrl').value.trim();
        if (!streamName) { err.textContent = 'Stream name required'; return; }
        // URL-dependent validation
        let cadence = 0;
        let parserType = '';
        let parserConfig = '';
        const headers = document.getElementById('dsHeaders').value.trim() || null;
        if (url) {
            const cadenceMin = parseInt(document.getElementById('dsCadenceMin').value);
            if (!cadenceMin || cadenceMin < 15) { err.textContent = 'Cadence must be at least 15 minutes'; return; }
            cadence = cadenceMin * 60;
            parserType = document.getElementById('dsParserType').value;
            parserConfig = parserType === 'json_path'
                ? document.getElementById('dsParserJsonPath').value.trim()
                : document.getElementById('dsParserPython').value.trim();
            if (!parserConfig) { err.textContent = 'Parser config required'; return; }
            if (headers) {
                try { JSON.parse(headers); } catch(e) { err.textContent = 'Headers must be valid JSON'; return; }
            }
        }
        btnLoading(btn);
        const resp = await fetch('/api/network/data-source', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                stream_name: streamName,
                name: document.getElementById('dsName').value.trim(),
                description: document.getElementById('dsDescription').value.trim(),
                url: url,
                method: url ? document.getElementById('dsMethod').value : 'GET',
                headers: headers,
                cadence_seconds: cadence,
                parser_type: parserType,
                parser_config: parserConfig,
            })
        });
        btnDone(btn);
        const data = await resp.json();
        if (data.error) { err.textContent = data.error; return; }
        toggleDataSourceForm(false);
        loadPublications();
    }

    // ── Publications ──────────────────────────────────────────
    let showInactivePubs = false;
    let pubDrawerData = {observations: [], predictions: []};
    let pubDrawerTab = 'observations';
    let pubChart = null;

    function toggleInactivePubs() {
        showInactivePubs = !showInactivePubs;
        const btn = document.getElementById('pubsToggleInactive');
        btn.textContent = showInactivePubs ? 'Hide Inactive' : 'Show Inactive';
        loadPublications();
    }

    function closePubDrawer() {
        document.getElementById('pubDrawer').style.display = 'none';
        if (pubChart) { pubChart.destroy(); pubChart = null; }
    }

    function switchPubTab(tab, link) {
        pubDrawerTab = tab;
        document.querySelectorAll('#pubDrawerTabs .nav-link').forEach(l => l.classList.remove('active'));
        link.classList.add('active');
        renderPubDrawerTable();
    }

    function renderPubDrawerTable() {
        const head = document.getElementById('pubDrawerHead');
        const body = document.getElementById('pubDrawerBody');
        body.innerHTML = '';
        if (pubDrawerTab === 'observations') {
            head.innerHTML = '<tr><th>Seq</th><th>Observed At</th><th>Received At</th><th>Value</th></tr>';
            pubDrawerData.observations.forEach(o => {
                const row = document.createElement('tr');
                let val = o.value || '';
                try { val = JSON.stringify(JSON.parse(val)); } catch(e) {}
                if (val.length > 80) val = val.substring(0, 80) + '...';
                row.innerHTML =
                    '<td>' + (o.seq_num != null ? o.seq_num : '-') + '</td>' +
                    '<td>' + (o.observed_at ? formatTimeAgo(o.observed_at) : '-') + '</td>' +
                    '<td>' + formatTimeAgo(o.received_at) + '</td>' +
                    '<td><code>' + val + '</code></td>';
                body.appendChild(row);
            });
        } else {
            head.innerHTML = '<tr><th>Obs Seq</th><th>Observed At</th><th>Created At</th><th>Value</th><th>Published</th></tr>';
            pubDrawerData.predictions.forEach(p => {
                const row = document.createElement('tr');
                let val = p.value || '';
                try { val = JSON.stringify(JSON.parse(val)); } catch(e) {}
                if (val.length > 80) val = val.substring(0, 80) + '...';
                row.innerHTML =
                    '<td>' + (p.observation_seq != null ? p.observation_seq : '-') + '</td>' +
                    '<td>' + (p.observed_at ? formatTimeAgo(p.observed_at) : '-') + '</td>' +
                    '<td>' + formatTimeAgo(p.created_at) + '</td>' +
                    '<td><code>' + val + '</code></td>' +
                    '<td>' + (p.published ? '<span class="badge bg-success">Yes</span>' : '<span class="badge bg-secondary">No</span>') + '</td>';
                body.appendChild(row);
            });
        }
        if (body.children.length === 0) {
            body.innerHTML = '<tr><td colspan="5" class="text-center text-muted">No data yet.</td></tr>';
        }
    }

    function renderPubChart() {
        const container = document.getElementById('pubChartContainer');
        const ctx = document.getElementById('pubChart');
        if (pubChart) { pubChart.destroy(); pubChart = null; }
        const obsPoints = pubDrawerData.observations
            .slice().reverse()
            .map(o => ({x: (o.observed_at || o.received_at) * 1000, y: tryParseFloat(o.value)}))
            .filter(p => p.y !== null);
        const obsTimes = obsPoints.map(p => p.x);
        const rawPreds = pubDrawerData.predictions
            .slice().reverse()
            .map(p => ({x: (p.observed_at || p.created_at) * 1000, y: tryParseFloat(p.value)}))
            .filter(p => p.y !== null);
        let cadenceMs = 0;
        if (obsTimes.length >= 2) {
            const diffs = [];
            for (let i = 1; i < obsTimes.length; i++) diffs.push(obsTimes[i] - obsTimes[i-1]);
            cadenceMs = diffs.reduce((a, b) => a + b, 0) / diffs.length;
        }
        const predPoints = rawPreds.map(p => {
            const obsIdx = obsTimes.findIndex(t => t >= p.x);
            const nextIdx = obsIdx >= 0 ? obsIdx + 1 : -1;
            if (nextIdx >= 0 && nextIdx < obsTimes.length) {
                return {x: obsTimes[nextIdx], y: p.y};
            }
            const lastTime = obsTimes.length > 0 ? obsTimes[obsTimes.length - 1] : p.x;
            return {x: lastTime + (cadenceMs || 60000), y: p.y};
        });
        if (obsPoints.length === 0 && predPoints.length === 0) {
            container.style.display = 'none';
            return;
        }
        container.style.display = 'block';
        const datasets = [];
        if (obsPoints.length > 0) {
            datasets.push({
                label: 'Observations',
                data: obsPoints,
                borderColor: 'rgba(54, 162, 235, 1)',
                backgroundColor: 'rgba(54, 162, 235, 0.1)',
                borderWidth: 2, pointRadius: 3, tension: 0.1, fill: false,
            });
        }
        if (predPoints.length > 0) {
            datasets.push({
                label: 'Predictions',
                data: predPoints,
                borderColor: 'rgba(255, 159, 64, 1)',
                backgroundColor: 'rgba(255, 159, 64, 0.1)',
                borderWidth: 2, pointRadius: 3, tension: 0.1,
                borderDash: [5, 3], fill: false,
            });
        }
        pubChart = new Chart(ctx, {
            type: 'line',
            data: {datasets},
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {mode: 'index', intersect: false},
                scales: {
                    x: {type: 'time', time: {tooltipFormat: 'MMM d, HH:mm'}},
                    y: {beginAtZero: false},
                },
                plugins: {legend: {position: 'top'}},
            },
        });
    }

    async function openPubDrawer(pub) {
        // If this is a data source publication (not a prediction), open edit form
        if (!pub.source_stream_name) {
            const opened = await editDataSource(pub.stream_name);
            if (opened) return;
        }
        const drawer = document.getElementById('pubDrawer');
        const title = document.getElementById('pubDrawerTitle');
        const body = document.getElementById('pubDrawerBody');
        title.textContent = pub.stream_name;
        body.innerHTML = '<tr><td colspan="4" class="text-center"><span class="spinner-border spinner-border-sm"></span> Loading...</td></tr>';
        drawer.style.display = 'block';
        pubDrawerTab = 'observations';
        document.querySelectorAll('#pubDrawerTabs .nav-link').forEach((l, i) =>
            i === 0 ? l.classList.add('active') : l.classList.remove('active'));
        // For prediction publications, load source stream data
        const srcStream = pub.source_stream_name;
        const srcPubkey = pub.source_provider_pubkey;
        if (srcStream && srcPubkey) {
            try {
                const resp = await fetch('/api/network/observations?stream_name=' +
                    encodeURIComponent(srcStream) + '&provider_pubkey=' +
                    encodeURIComponent(srcPubkey));
                pubDrawerData = await resp.json();
            } catch(e) {
                pubDrawerData = {observations: [], predictions: []};
            }
        } else {
            pubDrawerData = {observations: [], predictions: []};
        }
        renderPubChart();
        renderPubDrawerTable();
    }

    async function loadPublications() {
        try {
            const url = showInactivePubs
                ? '/api/network/publications?all=1'
                : '/api/network/publications';
            const resp = await fetch(url);
            const data = await resp.json();
            const empty = document.getElementById('pubsEmpty');
            const table = document.getElementById('pubsTable');
            const list = document.getElementById('pubsList');

            if (!data.publications || data.publications.length === 0) {
                empty.style.display = 'block';
                table.style.display = 'none';
                return;
            }
            empty.style.display = 'none';
            table.style.display = 'block';
            list.innerHTML = '';
            data.publications.forEach((p, idx) => {
                const row = document.createElement('tr');
                const inactive = p.active === 0;
                if (inactive) row.classList.add('text-muted');
                const statusBadge = inactive
                    ? '<span class="badge bg-secondary">Inactive</span>'
                    : '<span class="badge bg-success">Active</span>';
                const source = p.source_stream_name
                    ? '<small class="text-muted">' + p.source_stream_name + '</small>'
                    : '<span class="badge bg-info">Original</span>';
                const actionBtn = inactive
                    ? ''
                    : '<button class="btn btn-sm btn-outline-danger" onclick="event.stopPropagation(); stopPublication(\'' +
                      p.stream_name.replace(/'/g, "\\'") + '\', this)">Stop</button>';
                // Store pub data for drawer click
                row.dataset.pubIdx = idx;
                row.style.cursor = 'pointer';
                row.onclick = function() { openPubDrawer(data.publications[idx]); };
                row.innerHTML =
                    '<td><strong>' + (p.name || p.stream_name) + '</strong></td>' +
                    '<td>' + source + '</td>' +
                    '<td>' + formatCadence(p.cadence_seconds) + '</td>' +
                    '<td>' + (p.last_seq_num || 0) + '</td>' +
                    '<td>' + statusBadge + '</td>' +
                    '<td>' + actionBtn + '</td>';
                list.appendChild(row);
            });
        } catch (err) { /* ignore */ }
    }

    async function stopPublication(streamName, btn) {
        if (btn) btnLoading(btn);
        await fetch('/api/network/stop-predict', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({stream_name: streamName.replace(/_pred$/, '')})
        });
        loadPublications();
        loadNetworkSubscriptions();
    }

    let cachedStreamsByRelay = {};

    function closeRelayDrawer() {
        document.getElementById('relayDrawer').style.display = 'none';
    }

    function renderDrawerStreams(streams, relayUrl) {
        const drawer = document.getElementById('relayDrawer');
        const title = document.getElementById('relayDrawerTitle');
        const list = document.getElementById('relayDrawerStreams');

        title.textContent = relayUrl;
        list.innerHTML = '';

        const active = streams.filter(s => s.active);
        if (active.length === 0) {
            list.innerHTML = '<tr><td colspan="6" class="text-center text-muted">No active streams</td></tr>';
        } else {
            active.sort((a, b) => (b.subscribed ? 1 : 0) - (a.subscribed ? 1 : 0));
            active.forEach(s => {
                const tags = (s.tags || []).map(t => '<span class="badge bg-secondary me-1">' + t + '</span>').join('');
                const row = document.createElement('tr');
                if (!s.subscribed) row.classList.add('text-muted');
                const btnClass = s.subscribed ? 'btn-outline-danger' : 'btn-outline-success';
                const btnText = s.subscribed ? 'Unsubscribe' : 'Subscribe';
                const btnAction = s.subscribed
                    ? "networkUnsubscribe('" + s.stream_name.replace(/'/g, "\\'") + "', '" + s.nostr_pubkey.replace(/'/g, "\\'") + "', this)"
                    : "networkSubscribe(" + JSON.stringify(s).replace(/'/g, "\\'") + ", this)";
                row.innerHTML =
                    '<td><strong>' + (s.name || s.stream_name) + '</strong><br><small class="text-muted">' + s.stream_name + '</small></td>' +
                    '<td>' + (s.description || '-') + '</td>' +
                    '<td>' + formatCadence(s.cadence_seconds) + '</td>' +
                    '<td>' + (s.price_per_obs > 0 ? s.price_per_obs + ' sats' : 'Free') + '</td>' +
                    '<td>' + tags + '</td>' +
                    '<td><button class="btn btn-sm ' + btnClass + '" onclick="' + btnAction + '">' + btnText + '</button></td>';
                list.appendChild(row);
            });
        }
        drawer.style.display = 'block';
    }

    async function openRelayDrawer(relayUrl) {
        const cached = cachedStreamsByRelay[relayUrl];
        if (cached && cached.length > 0) {
            renderDrawerStreams(cached, relayUrl);
            return;
        }
        // No cached data — discover this relay
        const drawer = document.getElementById('relayDrawer');
        const title = document.getElementById('relayDrawerTitle');
        const list = document.getElementById('relayDrawerStreams');
        title.textContent = relayUrl;
        list.innerHTML = '<tr><td colspan="6" class="text-center text-muted">Discovering streams...</td></tr>';
        drawer.style.display = 'block';
        try {
            const resp = await fetch('/api/network/streams/relay?url=' + encodeURIComponent(relayUrl));
            const data = await resp.json();
            cachedStreamsByRelay[relayUrl] = data.streams || [];
            renderDrawerStreams(cachedStreamsByRelay[relayUrl], relayUrl);
        } catch (err) {
            list.innerHTML = '<tr><td colspan="6" class="text-center text-danger">Discovery failed</td></tr>';
        }
    }

    function formatTimeAgo(ts) {
        if (!ts) return '-';
        const seconds = Math.floor(Date.now() / 1000) - ts;
        if (seconds < 60) return 'just now';
        if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
        if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
        return Math.floor(seconds / 86400) + 'd ago';
    }

    async function addRelay() {
        const input = document.getElementById('addRelayInput');
        const url = input.value.trim();
        if (!url) return;
        if (!url.startsWith('wss://') && !url.startsWith('ws://')) {
            input.classList.add('is-invalid');
            return;
        }
        input.classList.remove('is-invalid');
        input.disabled = true;
        await fetch('/api/network/relay', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({relay_url: url})
        });
        input.value = '';
        input.disabled = false;
        loadRelays();
    }

    async function deleteRelay(relayUrl) {
        await fetch('/api/network/relay', {
            method: 'DELETE',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({relay_url: relayUrl})
        });
        closeRelayDrawer();
        loadRelays();
    }

    async function loadRelays() {
        try {
            const resp = await fetch('/api/network/relays');
            const data = await resp.json();

            const loading = document.getElementById('relaysLoading');
            const empty = document.getElementById('relaysEmpty');
            const table = document.getElementById('relaysTable');
            const list = document.getElementById('relaysList');
            const status = document.getElementById('networkStatus');

            loading.style.display = 'none';
            status.className = 'badge bg-success';
            status.textContent = (data.relays || []).length + ' relays';

            const relays = data.relays || [];
            if (relays.length === 0) {
                empty.style.display = 'block';
                table.style.display = 'none';
                return;
            }

            empty.style.display = 'none';
            table.style.display = 'block';
            list.innerHTML = '';

            relays.forEach(r => {
                const row = document.createElement('tr');
                row.style.cursor = 'pointer';
                row.onclick = function() { openRelayDrawer(r.relay_url); };
                const sourceBadge = r.source === 'both'
                    ? '<span class="badge bg-info">server + local</span>'
                    : r.source === 'server'
                        ? '<span class="badge bg-secondary">server</span>'
                        : '<span class="badge bg-outline-secondary border">local</span>';
                const deleteBtn = r.source !== 'server'
                    ? '<button class="btn btn-sm btn-outline-danger" onclick="event.stopPropagation(); deleteRelay(\'' + r.relay_url.replace(/'/g, "\\'") + '\')"><i class="material-icons align-middle" style="font-size: 16px;">delete</i></button>'
                    : '';
                row.innerHTML =
                    '<td>' + r.relay_url + '</td>' +
                    '<td>' + formatTimeAgo(r.last_active) + '</td>' +
                    '<td>' + sourceBadge + '</td>' +
                    '<td>' + deleteBtn + '</td>' +
                    '<td><i class="material-icons align-middle" style="font-size: 18px;">chevron_right</i></td>';
                list.appendChild(row);
            });
        } catch (err) {
            document.getElementById('relaysLoading').textContent = 'Error loading relays';
            document.getElementById('networkStatus').className = 'badge bg-danger';
            document.getElementById('networkStatus').textContent = 'Error';
        }
    }
    // Wallet Card Functions
    let privateKeyLoaded = false;

    async function loadQrCode(address) {
        const qrContainer = document.getElementById('walletQrCode');
        const result = await apiCall('/wallet/qr/' + encodeURIComponent(address));
        if (result && result.qr_code) {
            qrContainer.innerHTML = '<img src="' + result.qr_code + '" alt="QR Code" style="max-width: 150px;">';
        } else {
            qrContainer.innerHTML = '<p class="text-muted mb-0">QR code unavailable</p>';
        }
    }

    async function togglePrivateKey() {
        const showBtn = document.getElementById('showPrivateKeyBtn');
        const section = document.getElementById('privateKeySection');

        if (section.style.display === 'none') {
            // Show private key (vault private key)
            if (!privateKeyLoaded) {
                const result = await apiCall('/wallet/private-key');
                if (result && result.private_key) {
                    document.getElementById('walletPrivateKey').textContent = result.private_key;
                    privateKeyLoaded = true;
                } else {
                    document.getElementById('walletPrivateKey').textContent = 'Unable to load private key';
                }
            }
            showBtn.style.display = 'none';
            section.style.display = 'block';
        } else {
            // Hide private key
            showBtn.style.display = 'block';
            section.style.display = 'none';
        }
    }

    function copyPrivateKey() {
        const privateKey = document.getElementById('walletPrivateKey').textContent;
        if (privateKey && privateKey !== 'Loading...' && privateKey !== 'Unable to load private key') {
            // Check if Clipboard API is available (requires HTTPS or localhost)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(privateKey).then(() => {
                    showToast('Private key copied to clipboard');
                }).catch(() => {
                    // Fallback for older browsers or non-HTTPS
                    const textArea = document.createElement('textarea');
                    textArea.value = privateKey;
                    textArea.style.position = 'fixed';
                    textArea.style.opacity = '0';
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        showToast('Private key copied to clipboard');
                    } catch (err) {
                        showToast('Failed to copy private key', true);
                    }
                    document.body.removeChild(textArea);
                });
            } else {
                // Fallback for older browsers or non-HTTPS
                const textArea = document.createElement('textarea');
                textArea.value = privateKey;
                textArea.style.position = 'fixed';
                textArea.style.opacity = '0';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    showToast('Private key copied to clipboard');
                } catch (err) {
                    showToast('Failed to copy private key', true);
                }
                document.body.removeChild(textArea);
            }
        }
    }

    function toggleSweepAmount() {
        const sweepCheckbox = document.getElementById('sendSweep');
        const amountInput = document.getElementById('sendAmount');
        if (sweepCheckbox.checked) {
            amountInput.disabled = true;
            amountInput.value = '';
            amountInput.placeholder = 'All tokens';
        } else {
            amountInput.disabled = false;
            amountInput.placeholder = '0.00';
        }
    }

    async function sendTransaction() {
        const address = document.getElementById('sendDestAddress').value.trim();
        const amount = document.getElementById('sendAmount').value;
        const sweep = document.getElementById('sendSweep').checked;
        const sendBtn = document.getElementById('sendBtn');
        const resultDiv = document.getElementById('sendResult');

        // Get selected source (wallet or vault)
        const sendSource = document.querySelector('input[name="sendSource"]:checked').value;
        const sourceName = sendSource === 'wallet' ? 'Identity Wallet' : 'Vault';

        // Validate
        if (!address) {
            showToast('Please enter a destination address', true);
            return;
        }
        if (!isValidAddress(address)) {
            showToast('Invalid address: must start with E and be 34 characters', true);
            return;
        }
        if (!sweep && (!amount || parseFloat(amount) <= 0)) {
            showToast('Please enter an amount or select "Send All"', true);
            return;
        }

        // Confirm with source information
        const confirmMsg = sweep
            ? 'Send ALL tokens from ' + sourceName + ' to ' + address + '?'
            : 'Send ' + amount + ' SATORI from ' + sourceName + ' to ' + address + '?';
        if (!confirm(confirmMsg)) {
            return;
        }

        // Send
        sendBtn.disabled = true;
        sendBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Sending...';
        resultDiv.style.display = 'none';

        try {
            const data = { address: address, sweep: sweep };
            if (!sweep) {
                data.amount = parseFloat(amount);
            }

            // Use the appropriate endpoint based on source selection
            const endpoint = sendSource === 'wallet' ? '/wallet/send-from-wallet' : '/wallet/send';
            const result = await apiCall(endpoint, 'POST', data);

            if (result && result.success) {
                resultDiv.className = 'mt-3 alert alert-success';
                resultDiv.innerHTML = '<strong>Success!</strong><br>Sent from ' + sourceName + '<br>Transaction ID: <code style="word-break: break-all;">' + result.txid + '</code>';
                resultDiv.style.display = 'block';
                showToast('Transaction sent successfully from ' + sourceName + '!');
                // Clear form
                document.getElementById('sendDestAddress').value = '';
                document.getElementById('sendAmount').value = '';
                document.getElementById('sendSweep').checked = false;
                toggleSweepAmount();
                // Refresh balances to show updated amounts
                refreshBalance();
            } else {
                const errorMsg = result ? (result.error || 'Transaction failed') : 'Transaction failed';
                resultDiv.className = 'mt-3 alert alert-danger';
                resultDiv.innerHTML = '<strong>Error:</strong> ' + errorMsg;
                resultDiv.style.display = 'block';
                showToast('Transaction failed: ' + errorMsg, true);
            }
        } catch (error) {
            resultDiv.className = 'mt-3 alert alert-danger';
            resultDiv.innerHTML = '<strong>Error:</strong> ' + error.message;
            resultDiv.style.display = 'block';
            showToast('Transaction error: ' + error.message, true);
        } finally {
            sendBtn.disabled = false;
            sendBtn.innerHTML = '<i class="material-icons align-middle me-1">send</i> Send Transaction';
        }
    }

    // AI Engine Training Frequency Control
    function sliderToSeconds(sliderValue) {
        // Convert slider percentage to seconds (non-linear logarithmic scale)
        // 0% = 24 hours, 25% = 1 hour, 50% = 10 min, 75% = 1 min, 100% = 0 sec
        const percentage = sliderValue / 100.0;

        if (percentage <= 0.0) return 86400;  // 24 hours
        if (percentage >= 1.0) return 0;      // continuous

        // Improved logarithmic scale using exponential decay
        // Maps 0%->86400s (24h), 50%->675s (~11min), 100%->0s (continuous)
        const delay = Math.round(86400 * Math.pow(1 - percentage, 7));
        return delay;
    }

    function secondsToSlider(seconds) {
        // Convert seconds to slider percentage (inverse of sliderToSeconds)
        if (seconds >= 86400) return 0;
        if (seconds <= 0) return 100;

        // Inverse of logarithmic scale
        const percentage = 1 - Math.pow(seconds / 86400, 1/7);
        return Math.round(percentage * 100);
    }

    function formatDelay(seconds) {
        // Format seconds into human-readable string
        if (seconds === 0) return "Continuous";
        if (seconds < 60) return seconds + " seconds";
        if (seconds < 3600) return Math.round(seconds / 60) + " minutes";
        if (seconds < 86400) return Math.round(seconds / 3600) + " hours";
        return Math.round(seconds / 86400) + " days";
    }

    function updateTrainingDelayLabel(sliderValue) {
        // Update label as slider moves
        const seconds = sliderToSeconds(sliderValue);
        document.getElementById('trainingDelayLabel').textContent = formatDelay(seconds);
    }

    async function setTrainingDelay(sliderValue) {
        // Save to backend when slider changes
        const seconds = sliderToSeconds(sliderValue);

        try {
            const result = await apiCall('/engine/training-delay', 'POST', {
                delay_seconds: seconds
            });

            if (result && !result.error) {
                showToast(`Training frequency updated: ${formatDelay(seconds)}`);
            } else {
                showToast('Failed to update training frequency', true);
            }
        } catch (error) {
            console.error('Error setting training delay:', error);
            showToast('Failed to update training frequency', true);
        }
    }

    async function loadTrainingDelay() {
        // Load current setting on page load
        try {
            const result = await apiCall('/engine/training-delay');

            if (result && result.delay_seconds !== undefined) {
                const sliderValue = secondsToSlider(result.delay_seconds);
                document.getElementById('trainingDelaySlider').value = sliderValue;
                updateTrainingDelayLabel(sliderValue);
            }
        } catch (error) {
            console.error('Error loading training delay:', error);
        }
    }

    // AI Engine Performance Charts
    let predVsObsChart = null;
    let accuracyChart = null;

    async function loadPerformance() {
        try {
            const data = await apiCall('/engine/performance');

            if (!data || data.error) {
                // Show message to user
                if (data?.error) {
                    showToast('Performance data unavailable: ' + data.error, true);
                }
                return;
            }

            // Check if we have any data
            const hasData = (data.observations && data.observations.length > 0) ||
                           (data.predictions && data.predictions.length > 0);

            if (!hasData) {
                // Update stats to show no data
                document.getElementById('accuracyPct').textContent = '--';
                document.getElementById('avgError').textContent = 'No data yet';
                document.getElementById('avgAbsError').textContent = '--';
                return;
            }

            // Update stats
            if (data.stats) {
                document.getElementById('accuracyPct').textContent =
                    data.stats.accuracy_pct ? `${data.stats.accuracy_pct}%` : '--';
                document.getElementById('avgError').textContent =
                    data.stats.avg_error !== undefined ? data.stats.avg_error.toFixed(2) : '--';
                document.getElementById('avgAbsError').textContent =
                    data.stats.avg_abs_error !== undefined ? data.stats.avg_abs_error.toFixed(2) : '--';
            }

            renderPredVsObsChart(data.observations, data.predictions, data.accuracy);
            renderAccuracyChart(data.accuracy);
        } catch (error) {
            console.error('Error loading performance data:', error);
            showToast('Failed to load performance data', true);
        }
    }

    function renderPredVsObsChart(observations, predictions, accuracyData) {
        try {
            const ctx = document.getElementById('predVsObsChart');
            if (!ctx) {
                console.error('Chart canvas element not found: predVsObsChart');
                return;
            }

            if (predVsObsChart) predVsObsChart.destroy();

            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const textColor = isDark ? '#a0a0a0' : '#555555';
            const gridColor = isDark ? 'rgba(255, 255, 255, 0.08)' : 'rgba(0, 0, 0, 0.08)';

            // Helper function to parse timestamp (handles both Unix timestamps and date strings)
            const parseTimestamp = (ts) => {
                // Check if it's a pure numeric string (Unix timestamp)
                if (/^\d+\.?\d*$/.test(ts)) {
                    const numTs = parseFloat(ts);
                    // Unix timestamp - multiply by 1000 if in seconds
                    return numTs < 10000000000 ? new Date(numTs * 1000) : new Date(numTs);
                } else {
                    // Date string (like "2025-12-21 06:55:47.484299")
                    // Add 'Z' to parse as UTC if not already present
                    const dateStr = ts.includes('Z') ? ts : ts.replace(' ', 'T') + 'Z';
                    return new Date(dateStr);
                }
            };

            // Convert observations data - use sequential positions
            const obsData = observations.map((o, i) => ({
                x: i,  // Use index as x-position
                y: parseFloat(o.value)
            }));

            // Convert predictions data - shift forward by 1 position
            // prediction[i] should be at position i+1 to align with observation[i+1]
            const predData = predictions.map((p, i) => ({
                x: i + 1,  // Shift forward: pred[0] at position 1, pred[1] at position 2, etc.
                y: parseFloat(p.value)
            }));

            // Create index-based lookup maps
            // observation[i] -> prediction[i+1] (observation produces next prediction)
            // prediction[i] -> observation[i-1] (prediction was made from previous observation)
            const obsToPredMap = new Map();
            const predToObsMap = new Map();

            // Build obsToPredMap: observation[i] maps to prediction[i+1]
            observations.forEach((obs, i) => {
                if (i + 1 < predictions.length) {
                    const nextPred = predictions[i + 1];
                    obsToPredMap.set(obs.ts, {
                        ts: nextPred.ts,
                        value: parseFloat(nextPred.value),
                        timestamp: parseTimestamp(nextPred.ts)
                    });
                }
                // First observation has no prediction to show (it produces the next one)
            });

            // Build predToObsMap: prediction[i] maps to observation[i-1]
            predictions.forEach((pred, i) => {
                if (i - 1 >= 0 && i - 1 < observations.length) {
                    const prevObs = observations[i - 1];
                    predToObsMap.set(pred.ts, {
                        ts: prevObs.ts,
                        value: parseFloat(prevObs.value),
                        timestamp: parseTimestamp(prevObs.ts)
                    });
                }
                // First prediction has no prior observation in our data
            });

            predVsObsChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Observations',
                    data: obsData,
                    borderColor: 'rgb(75, 192, 192)',
                    borderWidth: 2,
                    pointRadius: 2
                }, {
                    label: 'Predictions',
                    data: predData,
                    borderColor: 'rgb(153, 102, 255)',
                    borderWidth: 2,
                    pointRadius: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        ticks: {
                            color: textColor,
                            callback: function(value, index) {
                                // Show timestamp labels for select points
                                if (index >= observations.length - 3 || index === 0) {
                                    const obs = observations[value];
                                    if (obs) {
                                        return new Date(parseTimestamp(obs.ts)).toLocaleTimeString();
                                    }
                                }
                                return '';
                            }
                        },
                        grid: { color: gridColor }
                    },
                    y: {
                        ticks: { color: textColor },
                        grid: { color: gridColor }
                    }
                },
                plugins: {
                    legend: { labels: { color: textColor } },
                    tooltip: {
                        mode: 'point',
                        intersect: false,
                        callbacks: {
                            title: function(tooltipItems) {
                                const index = Math.round(tooltipItems[0].parsed.x);
                                const obs = observations[index];
                                if (obs) {
                                    return new Date(parseTimestamp(obs.ts)).toLocaleString();
                                }
                                return 'Index: ' + index;
                            },
                            label: function(context) {
                                const datasetLabel = context.dataset.label;
                                const value = context.parsed.y;
                                const position = Math.round(context.parsed.x);

                                if (datasetLabel === 'Observations') {
                                    // observation is at position i
                                    const obsData = observations[position];
                                    if (!obsData) {
                                        // No observation at this position (future prediction only)
                                        return null;
                                    }
                                    const obsTime = new Date(parseTimestamp(obsData.ts)).toLocaleTimeString();
                                    return `Observation: ${value.toFixed(2)} (at ${obsTime})`;

                                } else if (datasetLabel === 'Predictions') {
                                    // prediction[i] is at position i+1, so prediction at position p is predictions[p-1]
                                    const predIndex = position - 1;
                                    if (predIndex < 0 || predIndex >= predictions.length) {
                                        // No prediction at this position (first observation has no prediction)
                                        return null;
                                    }
                                    const predData = predictions[predIndex];
                                    if (!predData) {
                                        return null;
                                    }
                                    const predTime = new Date(parseTimestamp(predData.ts)).toLocaleTimeString();
                                    return `Prediction: ${value.toFixed(2)} (at ${predTime})`;
                                }

                                return null;
                            }
                        }
                    }
                },
                interaction: {
                    mode: 'point',
                    intersect: false
                }
            }
        });
        } catch (error) {
            console.error('Error rendering predictions vs observations chart:', error);
            showToast('Error rendering chart: ' + error.message, true);
        }
    }

    function renderAccuracyChart(accuracyData) {
        try {
            const ctx = document.getElementById('accuracyChart');
            if (!ctx) {
                console.error('Chart canvas element not found: accuracyChart');
                return;
            }

            if (accuracyChart) accuracyChart.destroy();

        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        const textColor = isDark ? '#a0a0a0' : '#555555';
        const gridColor = isDark ? 'rgba(255, 255, 255, 0.08)' : 'rgba(0, 0, 0, 0.08)';

        // Helper function to parse timestamp (same as in renderPredVsObsChart)
        const parseTimestamp = (ts) => {
            if (/^\d+\.?\d*$/.test(ts)) {
                const numTs = parseFloat(ts);
                return numTs < 10000000000 ? new Date(numTs * 1000) : new Date(numTs);
            } else {
                const dateStr = ts.includes('Z') ? ts : ts.replace(' ', 'T') + 'Z';
                return new Date(dateStr);
            }
        };

        accuracyChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Absolute Error',
                    data: accuracyData.map((a, i) => ({ x: i, y: a.abs_error })),
                    borderColor: 'rgb(255, 99, 132)',
                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                    borderWidth: 2,
                    pointRadius: 2,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        ticks: {
                            color: textColor,
                            callback: function(value, index) {
                                // Show timestamp labels for select points
                                if (index >= accuracyData.length - 3 || index === 0) {
                                    const acc = accuracyData[value];
                                    if (acc) {
                                        return parseTimestamp(acc.ts).toLocaleTimeString();
                                    }
                                }
                                return '';
                            }
                        },
                        grid: { color: gridColor }
                    },
                    y: {
                        beginAtZero: true,
                        ticks: { color: textColor },
                        grid: { color: gridColor }
                    }
                },
                plugins: {
                    legend: { labels: { color: textColor } },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: function(tooltipItems) {
                                const index = Math.round(tooltipItems[0].parsed.x);
                                const acc = accuracyData[index];
                                if (acc) {
                                    return parseTimestamp(acc.ts).toLocaleString();
                                }
                                return 'Index: ' + index;
                            },
                            label: function(context) {
                                return 'Absolute Error: ' + context.parsed.y.toFixed(4);
                            }
                        }
                    }
                },
                interaction: {
                    mode: 'index',
                    intersect: false
                }
            }
        });
        } catch (error) {
            console.error('Error rendering accuracy chart:', error);
            showToast('Error rendering accuracy chart: ' + error.message, true);
        }
    }

    function refreshPerformance() {
        showToast('Refreshing performance data...', 'info');
        loadPerformance();
    }

    // Wallet Import Functionality
    let walletImportFilesModal = [];
    const systemStatsCharts = { cpu: null, mem: null, disk: null, proc: null };
    const systemStatsHistory = [];
    let systemStatsTimer = null;
    const dashboardLayoutStorageKey = 'satori-dashboard-layout-v1';
    const p2pLayoutStorageKey = 'satori-p2p-layout-v1';

    function openImportWalletModal() {
        const modal = new bootstrap.Modal(document.getElementById('importWalletModal'));
        modal.show();
    }

    function handleWalletFolderSelectModal(event) {
        const files = Array.from(event.target.files);
        const importBtn = document.getElementById('importWalletBtnModal');
        const fileListDiv = document.getElementById('importFileListModal');
        const fileListItems = document.getElementById('importFileListItemsModal');

        walletImportFilesModal = [];
        fileListItems.innerHTML = '';

        if (files.length === 0) {
            importBtn.disabled = true;
            fileListDiv.style.display = 'none';
            return;
        }

        // Validate folder name is "wallet"
        const firstFile = files[0];
        const pathParts = firstFile.webkitRelativePath.split('/');
        const folderName = pathParts[0];

        if (folderName !== 'wallet') {
            showToast('Please select a folder named "wallet"', true);
            event.target.value = '';
            importBtn.disabled = true;
            fileListDiv.style.display = 'none';
            return;
        }

        // Filter to only .yaml files
        const yamlFiles = files.filter(f =>
            f.name.endsWith('.yaml') || f.name.endsWith('.yml')
        );

        // Check for required files
        const fileNames = yamlFiles.map(f => f.name);
        const hasWallet = fileNames.includes('wallet.yaml');
        const hasVault = fileNames.includes('vault.yaml');

        if (!hasWallet || !hasVault) {
            showToast('Wallet folder must contain wallet.yaml and vault.yaml', true);
            event.target.value = '';
            importBtn.disabled = true;
            fileListDiv.style.display = 'none';
            return;
        }

        // Valid files - show list
        walletImportFilesModal = yamlFiles;
        fileListItems.innerHTML = '';
        yamlFiles.forEach(file => {
            const li = document.createElement('li');
            li.innerHTML = `<code>${file.name}</code> (${(file.size / 1024).toFixed(2)} KB)`;
            fileListItems.appendChild(li);
        });

        fileListDiv.style.display = 'block';
        importBtn.disabled = false;
    }

    async function importWalletFromModal() {
        if (walletImportFilesModal.length === 0) {
            showToast('No files selected', true);
            return;
        }

        const importBtn = document.getElementById('importWalletBtnModal');
        const resultDiv = document.getElementById('importResultModal');

        // Confirm action
        const confirmMsg =
            'WARNING: This will replace your current wallet and restart the container!\n\n' +
            `Files to import: ${walletImportFilesModal.map(f => f.name).join(', ')}\n\n` +
            'Make sure you have backed up your current wallet.\n\n' +
            'Continue?';

        if (!confirm(confirmMsg)) {
            return;
        }

        // Disable button and show loading
        importBtn.disabled = true;
        importBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Importing...';
        resultDiv.style.display = 'none';

        try {
            // Prepare FormData
            const formData = new FormData();
            walletImportFilesModal.forEach(file => {
                formData.append('files', file, file.name);
            });

            // Upload files
            const response = await fetch('/api/wallet/import', {
                method: 'POST',
                body: formData
            });

            const data = await response.json();

            if (response.ok && data.success) {
                resultDiv.className = 'mt-3 alert alert-success';
                resultDiv.innerHTML =
                    '<strong>Success!</strong><br>' +
                    'Wallet imported successfully.<br>' +
                    'Container is restarting...<br>' +
                    '<small>Backup saved to: ' + data.backup_location + '</small><br>' +
                    '<small class="text-warning">Note: You\'ll need to set a new reward address after restart.</small>';
                resultDiv.style.display = 'block';

                showToast('Wallet imported! Container restarting...');

                // Show restart notice
                setTimeout(() => {
                    alert(
                        'Container Restarting\n\n' +
                        'The application is restarting with your imported wallet.\n' +
                        'Please wait 10-15 seconds, then refresh this page.\n\n' +
                        'You will need to:\n' +
                        '1. Log in again with your vault password\n' +
                        '2. Set a new reward address for this wallet'
                    );

                    // Auto-reload after 15 seconds
                    setTimeout(() => {
                        window.location.href = '/login';
                    }, 15000);
                }, 2000);

            } else {
                const errorMsg = data.error || 'Import failed';
                const rolledBack = data.rolled_back ? '\n\nYour old wallet has been restored.' : '';
                resultDiv.className = 'mt-3 alert alert-danger';
                resultDiv.innerHTML = '<strong>Error:</strong> ' + errorMsg + rolledBack;
                resultDiv.style.display = 'block';
                showToast('Import failed: ' + errorMsg, true);

                // Re-enable button
                importBtn.disabled = false;
                importBtn.innerHTML = '<i class="material-icons align-middle me-1">upload</i> Import Wallet & Restart';
            }

        } catch (error) {
            resultDiv.className = 'mt-3 alert alert-danger';
            resultDiv.innerHTML = '<strong>Error:</strong> ' + error.message;
            resultDiv.style.display = 'block';
            showToast('Import error: ' + error.message, true);

            // Re-enable button
            importBtn.disabled = false;
            importBtn.innerHTML = '<i class="material-icons align-middle me-1">upload</i> Import Wallet & Restart';
        }
    }

    function saveDashboardLayout() {
        const row = document.getElementById('dashboardLayoutRow');
        if (!row) return;
        const order = Array.from(row.querySelectorAll('.dashboard-widget-col'))
            .map((el) => el.dataset.widgetId)
            .filter(Boolean);
        localStorage.setItem(dashboardLayoutStorageKey, JSON.stringify(order));
    }

    function applySavedDashboardLayout() {
        const row = document.getElementById('dashboardLayoutRow');
        if (!row) return;
        const raw = localStorage.getItem(dashboardLayoutStorageKey);
        if (!raw) return;

        let saved = null;
        try {
            saved = JSON.parse(raw);
        } catch (e) {
            return;
        }
        if (!Array.isArray(saved) || saved.length === 0) return;

        const widgetMap = new Map(
            Array.from(row.querySelectorAll('.dashboard-widget-col'))
                .map((el) => [el.dataset.widgetId, el])
        );

        saved.forEach((widgetId) => {
            const el = widgetMap.get(widgetId);
            if (el) row.appendChild(el);
        });

        // Append any newly added widgets not present in saved layout.
        widgetMap.forEach((el) => {
            if (!saved.includes(el.dataset.widgetId)) {
                row.appendChild(el);
            }
        });
    }

    function initDashboardDragDrop() {
        const row = document.getElementById('dashboardLayoutRow');
        if (!row || typeof Sortable === 'undefined') return;

        Sortable.create(row, {
            animation: 180,
            easing: 'cubic-bezier(0.22, 1, 0.36, 1)',
            draggable: '.dashboard-widget-col',
            handle: '.card-header, .drag-handle',
            ghostClass: 'dragging',
            chosenClass: 'drop-target',
            forceFallback: false,
            filter: 'input,textarea,select,button,a,label,.btn,.form-control,.form-select,.dropdown-item',
            preventOnFilter: false,
            onEnd: () => {
                saveDashboardLayout();
            },
        });
    }

    function saveP2pLayout() {
        const row = document.getElementById('p2pLayoutRow');
        if (!row) return;
        const order = Array.from(row.querySelectorAll('.p2p-widget-col'))
            .map((el) => el.dataset.widgetId)
            .filter(Boolean);
        localStorage.setItem(p2pLayoutStorageKey, JSON.stringify(order));
    }

    function applySavedP2pLayout() {
        const row = document.getElementById('p2pLayoutRow');
        if (!row) return;
        const raw = localStorage.getItem(p2pLayoutStorageKey);
        if (!raw) return;

        let saved = null;
        try {
            saved = JSON.parse(raw);
        } catch (e) {
            return;
        }
        if (!Array.isArray(saved) || saved.length === 0) return;

        const widgetMap = new Map(
            Array.from(row.querySelectorAll('.p2p-widget-col'))
                .map((el) => [el.dataset.widgetId, el])
        );

        saved.forEach((widgetId) => {
            const el = widgetMap.get(widgetId);
            if (el) row.appendChild(el);
        });

        widgetMap.forEach((el) => {
            if (!saved.includes(el.dataset.widgetId)) {
                row.appendChild(el);
            }
        });
    }

    function initP2pDragDrop() {
        const row = document.getElementById('p2pLayoutRow');
        if (!row || typeof Sortable === 'undefined') return;

        Sortable.create(row, {
            animation: 180,
            easing: 'cubic-bezier(0.22, 1, 0.36, 1)',
            draggable: '.p2p-widget-col',
            handle: '.card-header, .drag-handle',
            ghostClass: 'dragging',
            chosenClass: 'drop-target',
            forceFallback: false,
            filter: 'input,textarea,select,button,a,label,.btn,.form-control,.form-select,.dropdown-item',
            preventOnFilter: false,
            onEnd: () => {
                saveP2pLayout();
            },
        });
    }

    function formatDuration(seconds) {
        if (seconds === null || seconds === undefined || Number.isNaN(Number(seconds))) return '--';
        const total = Math.max(0, Math.floor(Number(seconds)));
        const d = Math.floor(total / 86400);
        const h = Math.floor((total % 86400) / 3600);
        const m = Math.floor((total % 3600) / 60);
        if (d > 0) return `${d}d ${h}h`;
        if (h > 0) return `${h}h ${m}m`;
        return `${m}m`;
    }

    function systemParseTimestamp(ts) {
        const d = new Date(ts);
        if (!Number.isNaN(d.getTime())) return d;
        const n = Number(ts);
        if (!Number.isNaN(n)) {
            return new Date(n > 1e12 ? n : n * 1000);
        }
        return new Date();
    }

    function updateSystemStatsSummary(stats) {
        const cpu = stats?.cpu?.usage_percent;
        const mem = stats?.memory?.virtual?.usage_percent;
        const disk = stats?.disk?.root?.usage_percent;
        const procCpu = stats?.process?.cpu_percent;
        const uptime = stats?.uptime?.system_seconds;
        const processUptime = stats?.uptime?.process_seconds;
        const threads = stats?.process?.thread_count;
        const host = stats?.host || {};
        const memTotal = stats?.memory?.virtual?.total_bytes || 0;
        const procRss = stats?.process?.memory_rss_bytes || 0;
        const procMemPct = memTotal > 0 ? (procRss / memTotal) * 100 : null;

        document.getElementById('systemCpuCurrent').textContent = cpu !== null && cpu !== undefined ? `${Number(cpu).toFixed(1)}%` : '--';
        document.getElementById('systemMemCurrent').textContent = mem !== null && mem !== undefined ? `${Number(mem).toFixed(1)}%` : '--';
        document.getElementById('systemDiskCurrent').textContent = disk !== null && disk !== undefined ? `${Number(disk).toFixed(1)}%` : '--';
        document.getElementById('systemProcCpuCurrent').textContent = procCpu !== null && procCpu !== undefined ? `${Number(procCpu).toFixed(1)}%` : '--';
        document.getElementById('systemProcMemCurrent').textContent = procMemPct !== null && procMemPct !== undefined ? `${Number(procMemPct).toFixed(1)}%` : '--';
        document.getElementById('systemUptime').textContent = formatDuration(uptime);
        document.getElementById('systemProcessUptime').textContent = formatDuration(processUptime);
        document.getElementById('systemThreads').textContent = threads !== null && threads !== undefined ? String(threads) : '--';
        document.getElementById('systemHostInfo').textContent =
            `${host.hostname || 'unknown'} • ${host.system || '--'} ${host.release || ''}`.trim();

        const last = systemParseTimestamp(stats?.timestamp_utc || Date.now());
        document.getElementById('systemStatsLastUpdate').textContent = `Updated ${last.toLocaleTimeString()}`;
    }

    function createMiniSystemChart(canvasId, label, color) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return null;
        return new Chart(canvas, {
            type: 'line',
            data: {
                datasets: [
                    {
                        label: label,
                        data: [],
                        borderColor: color,
                        backgroundColor: `${color}33`,
                        tension: 0.25,
                        pointRadius: 0,
                        fill: true,
                    },
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: { legend: { display: false } },
                scales: {
                    x: {
                        type: 'time',
                        time: { tooltipFormat: 'HH:mm:ss' },
                        ticks: { maxTicksLimit: 4 },
                    },
                    y: {
                        beginAtZero: true,
                        suggestedMax: 100,
                        ticks: {
                            callback: (value) => `${value}%`,
                            maxTicksLimit: 4,
                        },
                    },
                },
            },
        });
    }

    function initSystemStatsCharts() {
        systemStatsCharts.cpu = createMiniSystemChart('systemCpuChart', 'CPU %', '#60a5fa');
        systemStatsCharts.mem = createMiniSystemChart('systemMemChart', 'Memory %', '#34d399');
        systemStatsCharts.disk = createMiniSystemChart('systemDiskChart', 'Disk %', '#fbbf24');
        systemStatsCharts.proc = createMiniSystemChart('systemProcChart', 'Process CPU %', '#f87171');
    }

    function refreshSystemStatsCharts() {
        const mapped = {
            cpu: systemStatsHistory.map((s) => ({ x: s.ts, y: s.cpu })),
            mem: systemStatsHistory.map((s) => ({ x: s.ts, y: s.mem })),
            disk: systemStatsHistory.map((s) => ({ x: s.ts, y: s.disk })),
            proc: systemStatsHistory.map((s) => ({ x: s.ts, y: s.proc })),
        };
        Object.keys(systemStatsCharts).forEach((key) => {
            const chart = systemStatsCharts[key];
            if (!chart) return;
            chart.data.datasets[0].data = mapped[key];
            chart.update('none');
        });
    }

    function pushSystemStatsPoint(stats) {
        systemStatsHistory.push({
            ts: systemParseTimestamp(stats?.timestamp_utc || Date.now()),
            cpu: stats?.cpu?.usage_percent ?? null,
            mem: stats?.memory?.virtual?.usage_percent ?? null,
            disk: stats?.disk?.root?.usage_percent ?? null,
            proc: stats?.process?.cpu_percent ?? null,
        });

        if (systemStatsHistory.length > 240) {
            systemStatsHistory.splice(0, systemStatsHistory.length - 240);
        }
    }

    async function loadSystemStats() {
        try {
            const response = await fetch('/api/system/stats');
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            const stats = await response.json();
            updateSystemStatsSummary(stats);
            pushSystemStatsPoint(stats);
            refreshSystemStatsCharts();
        } catch (error) {
            const lastUpdate = document.getElementById('systemStatsLastUpdate');
            if (lastUpdate) {
                lastUpdate.textContent = `Monitoring unavailable (${error.message})`;
            }
        }
    }

    // Initialize dashboard
    document.addEventListener('DOMContentLoaded', function() {
        if (pageMode === 'p2p') {
            applySavedP2pLayout();
            initP2pDragDrop();
            loadRelays();
            loadNetworkSubscriptions();
            loadPublications();
        } else {
            applySavedDashboardLayout();
            initDashboardDragDrop();
        }

        // Set up wallet import file input handler for modal
        const walletFolderInputModal = document.getElementById('walletFolderInputModal');
        if (walletFolderInputModal) {
            walletFolderInputModal.addEventListener('change', handleWalletFolderSelectModal);
        }

        // Update theme icon based on stored theme
        const storedTheme = localStorage.getItem('satori-theme') || 'dark';
        const themeIcon = document.getElementById('themeIcon');
        if (themeIcon) {
            themeIcon.textContent = storedTheme === 'dark' ? 'light_mode' : 'dark_mode';
        }

        // Initialize Bootstrap tooltips
        const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl);
        });

        // Ensure both pool cards start collapsed (will be expanded by API calls if needed)
        const poolStakingCollapse = document.getElementById('poolStakingCollapse');
        const poolManagementCollapse = document.getElementById('poolManagementCollapse');
        if (poolStakingCollapse) {
            poolStakingCollapse.classList.remove('show');
        }
        if (poolManagementCollapse) {
            poolManagementCollapse.classList.remove('show');
        }

        if (pageMode !== 'p2p') {
            // Health check disabled to reduce API load
            // checkHealth();
            loadWalletAddresses();
            loadAllBalances();  // Load both stake and live balances from ElectrumX
            loadRewardAddress();
            // Staking/pool API calls moved to dedicated Stake Management page
            // loadStakingStatus();
            // loadWorkers();
            // loadLenders();
            // loadAvailablePools();
            // loadPoolCommission();
            const trainingDelaySlider = document.getElementById('trainingDelaySlider');
            if (trainingDelaySlider) {
                loadTrainingDelay();  // Load AI engine training frequency setting
            }
            initSystemStatsCharts();
            loadSystemStats();
            systemStatsTimer = setInterval(loadSystemStats, 3000);
        }

        // Periodic health check - Disabled to reduce unnecessary load
        // setInterval(checkHealth, 30000);
    });

    window.addEventListener('beforeunload', function() {
        if (systemStatsTimer) {
            clearInterval(systemStatsTimer);
            systemStatsTimer = null;
        }
    });
</script>
{% endblock %}
